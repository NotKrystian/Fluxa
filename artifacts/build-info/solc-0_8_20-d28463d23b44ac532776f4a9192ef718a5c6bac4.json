{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-d28463d23b44ac532776f4a9192ef718a5c6bac4",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "core/ArcAMMFactory.sol": "project/core/ArcAMMFactory.sol",
    "core/ArcAMMPool.sol": "project/core/ArcAMMPool.sol",
    "core/ArcExecutionHub.sol": "project/core/ArcExecutionHub.sol",
    "core/ArcMetaRouter.sol": "project/core/ArcMetaRouter.sol",
    "core/FluxaGateway.sol": "project/core/FluxaGateway.sol",
    "core/FluxaSwapRouter.sol": "project/core/FluxaSwapRouter.sol",
    "core/LiquidityVault.sol": "project/core/LiquidityVault.sol",
    "core/MockERC20.sol": "project/core/MockERC20.sol",
    "core/TokenRegistry.sol": "project/core/TokenRegistry.sol",
    "core/VaultFactory.sol": "project/core/VaultFactory.sol",
    "core/WrappedToken.sol": "project/core/WrappedToken.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ],
      "viaIR": true
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/draft-IERC6093.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)\npragma solidity >=0.8.4;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC1363.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/ERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /// @inheritdoc IERC20\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /// @inheritdoc IERC20\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /// @inheritdoc IERC20\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/extensions/IERC20Metadata.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/core/ArcAMMFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ArcAMMPool} from \"./ArcAMMPool.sol\";\n\n/// @title ArcAMMFactory\n/// @notice Factory for creating Arc AMM pool contracts for token pairs.\n/// @dev Creates ArcAMMPool instances with configurable swap fees and protocol fee settings.\ncontract ArcAMMFactory {\n    /// @notice Address that receives protocol fees from pools.\n    address public feeTo;\n\n    /// @notice Address that can change feeTo and feeToSetter.\n    address public feeToSetter;\n\n    /// @notice Default swap fee in basis points (e.g. 30 = 0.30%)\n    uint24 public defaultSwapFeeBps;\n\n    /// @notice Default protocol fee share in basis points (e.g. 1667 = 16.67% of swap fee)\n    uint24 public defaultProtocolFeeShareBps;\n\n    /// @notice tokenA => tokenB => pool address mapping.\n    mapping(address => mapping(address => address)) public getPair;\n\n    /// @notice List of all created pool addresses.\n    address[] public allPairs;\n\n    /// @notice Emitted when a new pool is created.\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256 index\n    );\n\n    /// @notice Emitted when the fee recipient is updated.\n    event FeeToUpdated(address indexed newFeeTo);\n\n    /// @notice Emitted when the feeToSetter is updated.\n    event FeeToSetterUpdated(address indexed newFeeToSetter);\n\n    /// @notice Emitted when default fee parameters are updated.\n    event DefaultFeesUpdated(uint24 swapFeeBps, uint24 protocolFeeShareBps);\n\n    /// @param _feeToSetter The initial address with permission to update fee settings.\n    /// @param _defaultSwapFeeBps Default swap fee for new pools (in basis points)\n    /// @param _defaultProtocolFeeShareBps Default protocol fee share for new pools\n    constructor(\n        address _feeToSetter,\n        uint24 _defaultSwapFeeBps,\n        uint24 _defaultProtocolFeeShareBps\n    ) {\n        require(_feeToSetter != address(0), \"ArcAMMFactory: ZERO_ADDRESS\");\n        require(_defaultSwapFeeBps < 10_000, \"ArcAMMFactory: FEE_TOO_HIGH\");\n        require(_defaultProtocolFeeShareBps <= 10_000, \"ArcAMMFactory: PROTOCOL_SHARE_TOO_HIGH\");\n        \n        feeToSetter = _feeToSetter;\n        defaultSwapFeeBps = _defaultSwapFeeBps;\n        defaultProtocolFeeShareBps = _defaultProtocolFeeShareBps;\n    }\n\n    // ========= VIEW FUNCTIONS =========\n\n    /// @notice Returns the number of pools created by this factory.\n    function allPairsLength() external view returns (uint256) {\n        return allPairs.length;\n    }\n\n    /// @notice Convenience getter to comply with IArcAMMFactory used by ArcMetaRouter.\n    /// @dev Returns the pool address for a token pair, or address(0) if none exists.\n    function getPool(address tokenA, address tokenB) external view returns (address) {\n        return getPair[tokenA][tokenB];\n    }\n\n    // ========= CORE LOGIC =========\n\n    /// @notice Create a new AMM pool for two tokens with default fee settings.\n    /// @param tokenA The first token address.\n    /// @param tokenB The second token address.\n    /// @return pair The address of the newly created pool.\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair) {\n        return createPairWithFees(\n            tokenA,\n            tokenB,\n            defaultSwapFeeBps,\n            defaultProtocolFeeShareBps\n        );\n    }\n\n    /// @notice Create a new AMM pool for two tokens with custom fee settings.\n    /// @param tokenA The first token address.\n    /// @param tokenB The second token address.\n    /// @param swapFeeBps Custom swap fee in basis points.\n    /// @param protocolFeeShareBps Custom protocol fee share in basis points.\n    /// @return pair The address of the newly created pool.\n    function createPairWithFees(\n        address tokenA,\n        address tokenB,\n        uint24 swapFeeBps,\n        uint24 protocolFeeShareBps\n    ) public returns (address pair) {\n        require(tokenA != tokenB, \"ArcAMMFactory: IDENTICAL_ADDRESSES\");\n        require(\n            tokenA != address(0) && tokenB != address(0),\n            \"ArcAMMFactory: ZERO_ADDRESS\"\n        );\n\n        (address token0, address token1) = _sortTokens(tokenA, tokenB);\n        require(\n            getPair[token0][token1] == address(0),\n            \"ArcAMMFactory: PAIR_EXISTS\"\n        );\n\n        // Deploy ArcAMMPool\n        ArcAMMPool pool = new ArcAMMPool(\n            token0,\n            token1,\n            swapFeeBps,\n            feeTo, // protocol fee recipient\n            protocolFeeShareBps\n        );\n\n        pair = address(pool);\n\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // convenience lookup\n\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length - 1);\n    }\n\n    // ========= FEE MANAGEMENT =========\n\n    /// @notice Set the fee recipient address.\n    /// @param _feeTo The new fee recipient.\n    function setFeeTo(address _feeTo) external {\n        require(msg.sender == feeToSetter, \"ArcAMMFactory: FORBIDDEN\");\n        feeTo = _feeTo;\n        emit FeeToUpdated(_feeTo);\n    }\n\n    /// @notice Set the feeToSetter address.\n    /// @param _feeToSetter The new feeToSetter.\n    function setFeeToSetter(address _feeToSetter) external {\n        require(msg.sender == feeToSetter, \"ArcAMMFactory: FORBIDDEN\");\n        require(_feeToSetter != address(0), \"ArcAMMFactory: ZERO_ADDRESS\");\n        feeToSetter = _feeToSetter;\n        emit FeeToSetterUpdated(_feeToSetter);\n    }\n\n    /// @notice Update default fee parameters for new pools.\n    /// @param _defaultSwapFeeBps New default swap fee in basis points.\n    /// @param _defaultProtocolFeeShareBps New default protocol fee share.\n    function setDefaultFees(\n        uint24 _defaultSwapFeeBps,\n        uint24 _defaultProtocolFeeShareBps\n    ) external {\n        require(msg.sender == feeToSetter, \"ArcAMMFactory: FORBIDDEN\");\n        require(_defaultSwapFeeBps < 10_000, \"ArcAMMFactory: FEE_TOO_HIGH\");\n        require(_defaultProtocolFeeShareBps <= 10_000, \"ArcAMMFactory: PROTOCOL_SHARE_TOO_HIGH\");\n        \n        defaultSwapFeeBps = _defaultSwapFeeBps;\n        defaultProtocolFeeShareBps = _defaultProtocolFeeShareBps;\n        emit DefaultFeesUpdated(_defaultSwapFeeBps, _defaultProtocolFeeShareBps);\n    }\n\n    // ========= INTERNAL HELPERS =========\n\n    /// @dev Returns sorted token addresses (token0 < token1).\n    function _sortTokens(\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, \"ArcAMMFactory: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n    }\n}\n"
      },
      "project/core/ArcAMMPool.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/// @title ArcAMMPool\n/// @notice Constant-product AMM pool for two ERC20 tokens.\n/// @dev LP tokens are this contract's ERC20; deploy via ArcAMMFactory.\ncontract ArcAMMPool is ERC20, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice Address of the AMM factory that deployed this pool\n    address public immutable factory;\n\n    /// @notice First token in the pair (sorted by address)\n    address public immutable token0;\n\n    /// @notice Second token in the pair (sorted by address)\n    address public immutable token1;\n\n    /// @notice Current reserves (amounts of token0 and token1)\n    uint112 private reserve0;\n    uint112 private reserve1;\n\n    /// @notice Swap fee in basis points (e.g. 30 = 0.30%)\n    uint24 public immutable swapFeeBps;\n\n    /// @notice Optional protocol fee recipient (0x0 disables protocol fee)\n    address public immutable protocolFeeRecipient;\n\n    /// @notice Protocol fee share of swapFee in basis points (e.g. 1667 of 10000 = 16.67% of swap fee)\n    uint24 public immutable protocolFeeShareBps;\n\n    uint256 private constant MINIMUM_LIQUIDITY = 10**3;\n    uint256 private constant BPS = 10_000;\n\n    // -----------------------------------------------------------------------\n    // Events\n    // -----------------------------------------------------------------------\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1, uint256 liquidity);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    // -----------------------------------------------------------------------\n    // Constructor\n    // -----------------------------------------------------------------------\n\n    /// @param _tokenA First token (unsorted)\n    /// @param _tokenB Second token (unsorted)\n    /// @param _swapFeeBps Total swap fee in BPS (1e4 = 100%)\n    /// @param _protocolFeeRecipient Address receiving protocol fees (can be address(0))\n    /// @param _protocolFeeShareBps Share of swapFee that goes to protocol in BPS (of BPS)\n    constructor(\n        address _tokenA,\n        address _tokenB,\n        uint24 _swapFeeBps,\n        address _protocolFeeRecipient,\n        uint24 _protocolFeeShareBps\n    ) ERC20(\"Arc AMM LP\", \"ARC-LP\") {\n        require(_tokenA != _tokenB, \"IDENTICAL_ADDRESSES\");\n        require(_tokenA != address(0) && _tokenB != address(0), \"ZERO_ADDRESS\");\n        require(_swapFeeBps < BPS, \"FEE_TOO_HIGH\");\n        require(_protocolFeeShareBps <= BPS, \"PROTOCOL_SHARE_TOO_HIGH\");\n\n        factory = msg.sender;\n\n        (address _token0, address _token1) = _tokenA < _tokenB\n            ? (_tokenA, _tokenB)\n            : (_tokenB, _tokenA);\n\n        token0 = _token0;\n        token1 = _token1;\n        swapFeeBps = _swapFeeBps;\n        protocolFeeRecipient = _protocolFeeRecipient;\n        protocolFeeShareBps = _protocolFeeShareBps;\n    }\n\n    // -----------------------------------------------------------------------\n    // Modifiers\n    // -----------------------------------------------------------------------\n\n    modifier onlyFactory() {\n        require(msg.sender == factory, \"ONLY_FACTORY\");\n        _;\n    }\n\n    // -----------------------------------------------------------------------\n    // Pool views\n    // -----------------------------------------------------------------------\n\n    /// @notice Returns the current reserves of token0 and token1\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n    }\n\n    /// @notice Returns the sorted tokens (token0, token1) for convenience\n    function getTokens() external view returns (address, address) {\n        return (token0, token1);\n    }\n\n    // -----------------------------------------------------------------------\n    // Internal helpers\n    // -----------------------------------------------------------------------\n\n    function _updateReserves(uint256 balance0, uint256 balance1) private {\n        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, \"OVERFLOW\");\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        emit Sync(reserve0, reserve1);\n    }\n\n    function _mintProtocolFee(uint256 liquidity) private {\n        if (protocolFeeRecipient == address(0) || protocolFeeShareBps == 0) return;\n        if (liquidity == 0) return;\n\n        uint256 protocolLiquidity = (liquidity * protocolFeeShareBps) / BPS;\n        if (protocolLiquidity > 0) {\n            _mint(protocolFeeRecipient, protocolLiquidity);\n        }\n    }\n\n    // -----------------------------------------------------------------------\n    // Liquidity management\n    // -----------------------------------------------------------------------\n\n    /// @notice Add liquidity to the pool\n    /// @param amount0Desired Desired amount of token0 to deposit\n    /// @param amount1Desired Desired amount of token1 to deposit\n    /// @param amount0Min Minimum amount of token0 that must be used (slippage protection)\n    /// @param amount1Min Minimum amount of token1 that must be used (slippage protection)\n    /// @param to Recipient of LP tokens\n    /// @return liquidity Amount of LP tokens minted\n    /// @return amount0 Actual amount of token0 deposited\n    /// @return amount1 Actual amount of token1 deposited\n    function addLiquidity(\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        address to\n    )\n        external\n        nonReentrant\n        returns (uint256 liquidity, uint256 amount0, uint256 amount1)\n    {\n        require(to != address(0), \"ZERO_TO\");\n        require(amount0Desired > 0 && amount1Desired > 0, \"INSUFFICIENT_INPUT\");\n\n        (uint112 _reserve0, uint112 _reserve1) = (reserve0, reserve1);\n        IERC20 _token0 = IERC20(token0);\n        IERC20 _token1 = IERC20(token1);\n\n        if (_reserve0 == 0 && _reserve1 == 0) {\n            // First liquidity sets the initial price; take desired amounts as-is\n            amount0 = amount0Desired;\n            amount1 = amount1Desired;\n        } else {\n            // Enforce ratio to keep price consistent with current reserves\n            uint256 amount1Optimal = (amount0Desired * _reserve1) / _reserve0;\n            if (amount1Optimal <= amount1Desired) {\n                require(amount1Optimal >= amount1Min, \"INSUFFICIENT_AMOUNT1\");\n                amount0 = amount0Desired;\n                amount1 = amount1Optimal;\n            } else {\n                uint256 amount0Optimal = (amount1Desired * _reserve0) / _reserve1;\n                require(amount0Optimal >= amount0Min, \"INSUFFICIENT_AMOUNT0\");\n                amount0 = amount0Optimal;\n                amount1 = amount1Desired;\n            }\n        }\n\n        // Pull tokens in\n        _token0.safeTransferFrom(msg.sender, address(this), amount0);\n        _token1.safeTransferFrom(msg.sender, address(this), amount1);\n\n        // Compute liquidity to mint\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply == 0) {\n            liquidity = _sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\n            // lock minimum liquidity forever (use address(1) instead of address(0) for OZ 5.x)\n            _mint(address(1), MINIMUM_LIQUIDITY);\n        } else {\n            liquidity = _min(\n                (amount0 * _totalSupply) / _reserve0,\n                (amount1 * _totalSupply) / _reserve1\n            );\n        }\n\n        require(liquidity > 0, \"INSUFFICIENT_LIQUIDITY_MINTED\");\n\n        // Mint protocol fee (if configured) and LP shares\n        _mintProtocolFee(liquidity);\n        _mint(to, liquidity);\n\n        // Update reserves to new balances\n        uint256 balance0 = _token0.balanceOf(address(this));\n        uint256 balance1 = _token1.balanceOf(address(this));\n        _updateReserves(balance0, balance1);\n\n        emit Mint(msg.sender, amount0, amount1, liquidity);\n    }\n\n    /// @notice Remove liquidity from the pool\n    /// @param liquidity Amount of LP tokens to burn\n    /// @param amount0Min Minimum amount of token0 expected\n    /// @param amount1Min Minimum amount of token1 expected\n    /// @param to Recipient of tokens\n    /// @return amount0 Amount of token0 withdrawn\n    /// @return amount1 Amount of token1 withdrawn\n    function removeLiquidity(\n        uint256 liquidity,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        address to\n    ) external nonReentrant returns (uint256 amount0, uint256 amount1) {\n        require(to != address(0), \"ZERO_TO\");\n        require(liquidity > 0, \"ZERO_LIQUIDITY\");\n\n        (uint112 _reserve0, uint112 _reserve1) = (reserve0, reserve1);\n        IERC20 _token0 = IERC20(token0);\n        IERC20 _token1 = IERC20(token1);\n\n        uint256 _totalSupply = totalSupply();\n\n        // burn LP\n        _burn(msg.sender, liquidity);\n\n        amount0 = (liquidity * _reserve0) / _totalSupply;\n        amount1 = (liquidity * _reserve1) / _totalSupply;\n        require(amount0 >= amount0Min, \"INSUFFICIENT_AMOUNT0\");\n        require(amount1 >= amount1Min, \"INSUFFICIENT_AMOUNT1\");\n\n        // send tokens\n        _token0.safeTransfer(to, amount0);\n        _token1.safeTransfer(to, amount1);\n\n        // update reserves\n        uint256 balance0 = _token0.balanceOf(address(this));\n        uint256 balance1 = _token1.balanceOf(address(this));\n        _updateReserves(balance0, balance1);\n\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // -----------------------------------------------------------------------\n    // Swapping\n    // -----------------------------------------------------------------------\n\n    /**\n     * @notice Swap an exact amountIn of tokenIn for tokenOut.\n     * @dev This overload is used by ArcMetaRouter. It assumes `amountIn` of tokenIn\n     *      has already been transferred into this pool (e.g. by the router).\n     *      The function computes the constant-product output amount with fees\n     *      and sends tokenOut to `to`.\n     */\n    function swap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        address to\n    ) external nonReentrant returns (uint256 amountOut) {\n        require(to != address(0), \"ZERO_TO\");\n        require(amountIn > 0, \"INSUFFICIENT_INPUT\");\n\n        bool zeroForOne;\n        if (tokenIn == token0 && tokenOut == token1) {\n            zeroForOne = true;\n        } else if (tokenIn == token1 && tokenOut == token0) {\n            zeroForOne = false;\n        } else {\n            revert(\"INVALID_PAIR\");\n        }\n\n        (uint112 _reserve0, uint112 _reserve1) = (reserve0, reserve1);\n        require(_reserve0 > 0 && _reserve1 > 0, \"NO_LIQUIDITY\");\n\n        IERC20 inToken = zeroForOne ? IERC20(token0) : IERC20(token1);\n        IERC20 outToken = zeroForOne ? IERC20(token1) : IERC20(token0);\n\n        uint256 reserveIn = zeroForOne ? _reserve0 : _reserve1;\n        uint256 reserveOut = zeroForOne ? _reserve1 : _reserve0;\n\n        // Optional sanity check: this pool should have at least reserveIn + amountIn of tokenIn\n        uint256 balanceIn = inToken.balanceOf(address(this));\n        require(balanceIn >= reserveIn + amountIn, \"INPUT_NOT_RECEIVED\");\n\n        // Apply fee on the input amount\n        uint256 amountInAfterFee = (amountIn * (BPS - swapFeeBps)) / BPS;\n\n        // Constant product formula: dy = (dx' * y) / (x + dx'), where dx' is after-fee\n        amountOut = (amountInAfterFee * reserveOut) / (reserveIn + amountInAfterFee);\n        require(amountOut > 0 && amountOut < reserveOut, \"INSUFFICIENT_OUTPUT\");\n\n        // Transfer out tokenOut to recipient\n        outToken.safeTransfer(to, amountOut);\n\n        // Update reserves based on current balances\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        _updateReserves(balance0, balance1);\n\n        // Emit Swap event with directional in/out\n        uint256 amount0In = zeroForOne ? amountIn : 0;\n        uint256 amount1In = zeroForOne ? 0 : amountIn;\n        uint256 amount0Out = zeroForOne ? 0 : amountOut;\n        uint256 amount1Out = zeroForOne ? amountOut : 0;\n\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    /// @notice Swap between token0 and token1\n    /// @param amount0Out Amount of token0 to send out (can be 0)\n    /// @param amount1Out Amount of token1 to send out (can be 0)\n    /// @param to Recipient of output tokens\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to\n    ) external nonReentrant {\n        require(amount0Out > 0 || amount1Out > 0, \"INSUFFICIENT_OUTPUT\");\n        require(to != address(0), \"ZERO_TO\");\n\n        (uint112 _reserve0, uint112 _reserve1) = (reserve0, reserve1);\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, \"INSUFFICIENT_LIQUIDITY\");\n\n        IERC20 _token0 = IERC20(token0);\n        IERC20 _token1 = IERC20(token1);\n\n        // optimistic transfer out\n        if (amount0Out > 0) _token0.safeTransfer(to, amount0Out);\n        if (amount1Out > 0) _token1.safeTransfer(to, amount1Out);\n\n        // compute balances after transfer out & user sending in\n        uint256 balance0 = _token0.balanceOf(address(this));\n        uint256 balance1 = _token1.balanceOf(address(this));\n\n        uint256 amount0In = balance0 > (_reserve0 - amount0Out)\n            ? balance0 - (_reserve0 - amount0Out)\n            : 0;\n        uint256 amount1In = balance1 > (_reserve1 - amount1Out)\n            ? balance1 - (_reserve1 - amount1Out)\n            : 0;\n\n        require(amount0In > 0 || amount1In > 0, \"INSUFFICIENT_INPUT\");\n\n        // apply fee to input side(s)\n        {\n            uint256 _swapFeeBps = swapFeeBps;\n            uint256 amount0InAfterFee = amount0In > 0\n                ? (amount0In * (BPS - _swapFeeBps)) / BPS\n                : 0;\n            uint256 amount1InAfterFee = amount1In > 0\n                ? (amount1In * (BPS - _swapFeeBps)) / BPS\n                : 0;\n\n            // constant product check: (reserve0 + inAfterFee0 - out0) * (reserve1 + inAfterFee1 - out1) >= reserve0 * reserve1\n            uint256 balance0Adjusted = _reserve0 + amount0InAfterFee - amount0Out;\n            uint256 balance1Adjusted = _reserve1 + amount1InAfterFee - amount1Out;\n            require(\n                balance0Adjusted * balance1Adjusted >= uint256(_reserve0) * uint256(_reserve1),\n                \"K\"\n            );\n        }\n\n        // update reserves\n        _updateReserves(balance0, balance1);\n\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // -----------------------------------------------------------------------\n    // Factory hooks (optional, extend later)\n    // -----------------------------------------------------------------------\n\n    /// @notice Hook for factory to skim accidentally sent tokens\n    function skim(address to) external onlyFactory nonReentrant {\n        IERC20 _token0 = IERC20(token0);\n        IERC20 _token1 = IERC20(token1);\n\n        uint256 balance0 = _token0.balanceOf(address(this));\n        uint256 balance1 = _token1.balanceOf(address(this));\n\n        if (balance0 > reserve0) {\n            _token0.safeTransfer(to, balance0 - reserve0);\n        }\n        if (balance1 > reserve1) {\n            _token1.safeTransfer(to, balance1 - reserve1);\n        }\n    }\n\n    /// @notice Force reserves sync in case of fee-on-transfer tokens, etc.\n    function sync() external nonReentrant {\n        IERC20 _token0 = IERC20(token0);\n        IERC20 _token1 = IERC20(token1);\n        _updateReserves(_token0.balanceOf(address(this)), _token1.balanceOf(address(this)));\n    }\n\n    // -----------------------------------------------------------------------\n    // Math utils\n    // -----------------------------------------------------------------------\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x < y ? x : y;\n    }\n\n    function _sqrt(uint256 y) private pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        // else z = 0\n    }\n}"
      },
      "project/core/ArcExecutionHub.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title ArcExecutionHub\n * @notice Internal execution hub on Arc for better swap prices\n * \n * This contract runs on Arc and executes swaps for users on other chains.\n * Users never interact with this directly - it's purely internal routing.\n * \n * Flow:\n * 1. Receives swap request from external chain via LayerZero\n * 2. Executes swap using Arc's deep liquidity pools\n * 3. Sends result back to origin chain via LayerZero\n * 4. Origin chain credits user (user never sees Arc)\n */\ncontract ArcExecutionHub is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // ============================================================================\n    // State Variables\n    // ============================================================================\n\n    /// @notice Arc AMM Pool for executing swaps\n    address public arcPool;\n\n    /// @notice LayerZero Endpoint\n    address public lzEndpoint;\n\n    /// @notice Mapping: origin chain ID => router address on that chain\n    mapping(uint32 => address) public remoteRouters;\n\n    /// @notice Pending executions (requestId => Execution)\n    mapping(bytes32 => Execution) public pendingExecutions;\n\n    // ============================================================================\n    // Structs\n    // ============================================================================\n\n    struct RoutePlan {\n        bytes32 requestId;\n        address user;\n        uint32 userChainId;\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint256 minAmountOut;\n        bool useArc;\n    }\n\n    struct Execution {\n        uint32 originChainId;\n        address originRouter;\n        address user;\n        address tokenOut;\n        uint256 minAmountOut;\n        bool completed;\n    }\n\n    // ============================================================================\n    // Events\n    // ============================================================================\n\n    event SwapReceived(\n        bytes32 indexed requestId,\n        uint32 indexed originChainId,\n        address indexed user,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    );\n\n    event SwapExecuted(\n        bytes32 indexed requestId,\n        address tokenOut,\n        uint256 amountOut\n    );\n\n    event ResultSent(\n        bytes32 indexed requestId,\n        uint32 indexed destinationChainId,\n        address indexed user,\n        uint256 amountOut\n    );\n\n    // ============================================================================\n    // Constructor\n    // ============================================================================\n\n    constructor(\n        address _arcPool,\n        address _lzEndpoint\n    ) Ownable(msg.sender) {\n        require(_arcPool != address(0), \"ZERO_POOL\");\n        require(_lzEndpoint != address(0), \"ZERO_ENDPOINT\");\n        \n        arcPool = _arcPool;\n        lzEndpoint = _lzEndpoint;\n    }\n\n    // ============================================================================\n    // LayerZero Receive (Internal Routing)\n    // ============================================================================\n\n    /**\n     * @notice Receive swap request from external chain via LayerZero\n     * @dev This would be called by LayerZero's lzReceive callback\n     * @param _srcChainId Origin chain ID\n     * @param _srcAddress Origin router address\n     * @param _nonce LayerZero nonce\n     * @param _payload Encoded RoutePlan\n     */\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external {\n        // In production, verify this is called by LayerZero endpoint\n        // require(msg.sender == lzEndpoint, \"ONLY_LZ\");\n        \n        // Verify sender is a known router\n        address srcRouter = _bytesToAddress(_srcAddress);\n        require(remoteRouters[uint32(_srcChainId)] == srcRouter, \"UNKNOWN_ROUTER\");\n\n        // Decode RoutePlan\n        RoutePlan memory plan = abi.decode(_payload, (RoutePlan));\n\n        // Store execution\n        pendingExecutions[plan.requestId] = Execution({\n            originChainId: plan.userChainId,\n            originRouter: srcRouter,\n            user: plan.user,\n            tokenOut: plan.tokenOut,\n            minAmountOut: plan.minAmountOut,\n            completed: false\n        });\n\n        emit SwapReceived(\n            plan.requestId,\n            plan.userChainId,\n            plan.user,\n            plan.tokenIn,\n            plan.tokenOut,\n            plan.amountIn\n        );\n\n        // Execute swap on Arc\n        _executeSwap(plan);\n    }\n\n    /**\n     * @notice Execute swap on Arc using deep liquidity pools\n     */\n    function _executeSwap(RoutePlan memory plan) internal {\n        // At this point, tokens should already be on Arc:\n        // - If tokenIn is USDC: received via CCTP\n        // - If tokenIn is FLX: received via Gateway wrapping\n        \n        // Execute swap on Arc pool\n        IERC20 tokenIn = IERC20(plan.tokenIn);\n        IERC20 tokenOut = IERC20(plan.tokenOut);\n\n        // Approve pool\n        tokenIn.approve(arcPool, plan.amountIn);\n\n        // Execute swap\n        (bool success, bytes memory data) = arcPool.call(\n            abi.encodeWithSignature(\n                \"swap(address,address,uint256,uint256,address)\",\n                plan.tokenIn,\n                plan.tokenOut,\n                plan.amountIn,\n                plan.minAmountOut,\n                address(this) // Receive result here\n            )\n        );\n\n        require(success, \"SWAP_FAILED\");\n        \n        uint256 amountOut = abi.decode(data, (uint256));\n        require(amountOut >= plan.minAmountOut, \"SLIPPAGE\");\n\n        Execution storage exec = pendingExecutions[plan.requestId];\n        exec.completed = true;\n\n        emit SwapExecuted(plan.requestId, plan.tokenOut, amountOut);\n\n        // Send result back to origin chain\n        _sendResultBack(plan.requestId, plan.userChainId, plan.user, plan.tokenOut, amountOut);\n    }\n\n    /**\n     * @notice Send swap result back to origin chain via LayerZero\n     */\n    function _sendResultBack(\n        bytes32 requestId,\n        uint32 destinationChainId,\n        address user,\n        address tokenOut,\n        uint256 amountOut\n    ) internal {\n        // Encode result message\n        bytes memory payload = abi.encode(\n            requestId,\n            tokenOut,\n            amountOut\n        );\n\n        // Send via LayerZero\n        // In production, use LayerZero SDK:\n        // lzEndpoint.send(\n        //     destinationChainId,\n        //     abi.encodePacked(remoteRouters[destinationChainId]),\n        //     payload,\n        //     payable(address(this)),\n        //     address(0),\n        //     bytes(\"\")\n        // );\n\n        emit ResultSent(requestId, destinationChainId, user, amountOut);\n    }\n\n    // ============================================================================\n    // Admin Functions\n    // ============================================================================\n\n    function setRemoteRouter(uint32 chainId, address router) external onlyOwner {\n        require(router != address(0), \"ZERO_ADDRESS\");\n        remoteRouters[chainId] = router;\n    }\n\n    function setArcPool(address _arcPool) external onlyOwner {\n        require(_arcPool != address(0), \"ZERO_ADDRESS\");\n        arcPool = _arcPool;\n    }\n\n    // ============================================================================\n    // Helper Functions\n    // ============================================================================\n\n    function _bytesToAddress(bytes calldata _bytes) internal pure returns (address) {\n        require(_bytes.length >= 20, \"INVALID_ADDRESS\");\n        address addr;\n        assembly {\n            addr := calldataload(_bytes.offset)\n        }\n        return addr;\n    }\n}\n\n"
      },
      "project/core/ArcMetaRouter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * ArcMetaRouter v0\n *\n * Single entrypoint for:\n * - Local USDC/EURC payments on Arc\n * - CCTP-based cross-chain USDC transfers\n * - Circle Gateway deposits (unified USDC balance)\n *\n * NOTE:\n * - You MUST plug in the correct addresses for:\n *   - USDC / EURC on Arc\n *   - TokenMessenger (CCTP) on Arc\n *   - GatewayWallet on Arc\n * - Function signatures for TokenMessenger may need slight adjustment\n *   based on the exact CCTP version deployed on Arc.\n */\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\n/**\n * Minimal interface for CCTP TokenMessenger on EVM.\n * Check the exact ABI for the Arc deployment and tweak as needed.\n *\n * Docs reference (EVM): https://developers.circle.com/cctp/evm-smart-contracts\n */\ninterface ITokenMessenger {\n    function depositForBurn(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken\n    ) external returns (uint64);\n\n    // V2 with hook & fast features – adjust if needed\n    function depositForBurnWithHook(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller,\n        uint256 maxFee,\n        uint32 minFinalityThreshold,\n        bytes calldata hookData\n    ) external returns (uint64);\n}\n\n/**\n * Minimal Circle Gateway Wallet interface.\n * Docs: https://developers.circle.com/gateway/references/contract-interfaces-and-events\n */\ninterface IGatewayWallet {\n    function deposit(address token, uint256 value) external;\n    function depositFor(address token, address depositor, uint256 value) external;\n\n    function totalBalance(address token, address depositor) external view returns (uint256);\n    function availableBalance(address token, address depositor) external view returns (uint256);\n}\n\n/**\n * Minimal interfaces for the Arc AMM factory and pool.\n * The concrete implementations live in core/ArcAMMFactory.sol and core/ArcAMMPool.sol.\n */\ninterface IArcAMMFactory {\n    function getPool(address tokenA, address tokenB) external view returns (address);\n}\n\n/**\n * VaultFactory interface - vaults ARE the pools\n */\ninterface IVaultFactory {\n    function getVault(address projectToken) external view returns (address);\n}\n\ninterface IArcAMMPool {\n    /**\n     * Swap an exact amountIn of tokenIn that has already been transferred into the pool.\n     * Implementing contract should:\n     * - verify tokenIn is one of the pool tokens\n     * - compute amountOut based on reserves and fee\n     * - send tokenOut to `to`\n     * - return amountOut\n     */\n    function swap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        address to\n    ) external returns (uint256 amountOut);\n}\n\n/**\n * Vault interface - vaults function as both vaults and AMM pools\n */\ninterface IVault {\n    /**\n     * Swap tokens - vaults are the liquidity pools\n     */\n    function swap(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address to\n    ) external returns (uint256 amountOut);\n    \n    function projectToken() external view returns (address);\n    function usdc() external view returns (address);\n}\n\n/**\n * Simple Ownable – you can replace with OZ's Ownable if you like.\n */\nabstract contract Ownable {\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"NOT_OWNER\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"ZERO_ADDR\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}\n\ncontract ArcMetaRouter is Ownable {\n    using SafeTransfer for IERC20;\n\n    enum RouteKind {\n        LOCAL,      // on-Arc transfers/escrow/etc.\n        CCTP,       // CCTP bridge via TokenMessenger\n        GATEWAY     // Circle Gateway Wallet deposit\n    }\n\n    // Tokens\n    IERC20 public immutable USDC;\n    IERC20 public immutable EURC;\n\n    // CCTP\n    ITokenMessenger public tokenMessenger;\n\n    // Circle Gateway\n    IGatewayWallet public gatewayWallet;\n\n    // Arc AMM\n    IArcAMMFactory public ammFactory;\n    IVaultFactory public vaultFactory; // Vaults ARE the pools\n\n    // Optional fee config (in bps, i.e. 100 = 1%)\n    uint16 public feeBps; // global fee applied to routed amount\n    address public feeCollector;\n\n    // ==== Events ====\n\n    event LocalPayment(\n        address indexed payer,\n        address indexed recipient,\n        address indexed token,\n        uint256 amount,\n        bytes32 paymentId\n    );\n\n    event CCTPTransferInitiated(\n        address indexed payer,\n        address indexed token,\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        uint64 nonce,\n        bytes hookData\n    );\n\n    event GatewayDeposit(\n        address indexed payer,\n        address indexed depositor,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LocalSwap(\n        address indexed sender,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        address recipient\n    );\n\n    event FeeUpdated(uint16 feeBps, address feeCollector);\n    event TokenMessengerUpdated(address tokenMessenger);\n    event GatewayWalletUpdated(address gatewayWallet);\n    event AMMFactoryUpdated(address ammFactory);\n\n    constructor(\n        address _usdc,\n        address _eurc,\n        address _tokenMessenger,\n        address _gatewayWallet,\n        uint16 _feeBps,\n        address _feeCollector\n    ) {\n        require(_usdc != address(0), \"USDC_ZERO\");\n        require(_eurc != address(0), \"EURC_ZERO\");\n        require(_feeCollector != address(0), \"FEE_COLLECTOR_ZERO\");\n\n        USDC = IERC20(_usdc);\n        EURC = IERC20(_eurc);\n        tokenMessenger = ITokenMessenger(_tokenMessenger);\n        gatewayWallet = IGatewayWallet(_gatewayWallet);\n        feeBps = _feeBps;\n        feeCollector = _feeCollector;\n\n        emit FeeUpdated(_feeBps, _feeCollector);\n        emit TokenMessengerUpdated(_tokenMessenger);\n        emit GatewayWalletUpdated(_gatewayWallet);\n    }\n\n    // ========= Admin setters =========\n\n    function setFeeConfig(uint16 _feeBps, address _feeCollector) external onlyOwner {\n        require(_feeCollector != address(0), \"FEE_COLLECTOR_ZERO\");\n        require(_feeBps <= 1_000, \"FEE_TOO_HIGH\"); // cap at 10% for safety\n        feeBps = _feeBps;\n        feeCollector = _feeCollector;\n        emit FeeUpdated(_feeBps, _feeCollector);\n    }\n\n    function setTokenMessenger(address _tokenMessenger) external onlyOwner {\n        require(_tokenMessenger != address(0), \"ZERO_ADDR\");\n        tokenMessenger = ITokenMessenger(_tokenMessenger);\n        emit TokenMessengerUpdated(_tokenMessenger);\n    }\n\n    function setGatewayWallet(address _gatewayWallet) external onlyOwner {\n        require(_gatewayWallet != address(0), \"ZERO_ADDR\");\n        gatewayWallet = IGatewayWallet(_gatewayWallet);\n        emit GatewayWalletUpdated(_gatewayWallet);\n    }\n\n    function setAMMFactory(address _ammFactory) external onlyOwner {\n        require(_ammFactory != address(0), \"ZERO_ADDR\");\n        ammFactory = IArcAMMFactory(_ammFactory);\n        emit AMMFactoryUpdated(_ammFactory);\n    }\n\n    function setVaultFactory(address _vaultFactory) external onlyOwner {\n        require(_vaultFactory != address(0), \"ZERO_ADDR\");\n        vaultFactory = IVaultFactory(_vaultFactory);\n    }\n\n    // ========= Core Routing =========\n\n    /**\n     * Local transfer on Arc with optional paymentId for business logic.\n     * This is the basic primitive you'll call for on-chain settlement flows.\n     */\n    function payLocal(\n        address token,\n        address recipient,\n        uint256 amount,\n        bytes32 paymentId\n    ) external {\n        require(recipient != address(0), \"RECIPIENT_ZERO\");\n        require(amount > 0, \"AMOUNT_ZERO\");\n        _checkSupportedToken(token);\n\n        IERC20 erc20 = IERC20(token);\n\n        (uint256 netAmount, uint256 fee) = _collectAndTakeFee(erc20, amount);\n\n        if (fee > 0) {\n            erc20.safeTransfer(feeCollector, fee);\n        }\n\n        erc20.safeTransfer(recipient, netAmount);\n\n        emit LocalPayment(msg.sender, recipient, token, netAmount, paymentId);\n    }\n\n    /**\n     * Local swap on Arc using the Arc AMM pools.\n     *\n     * Requirements:\n     * - A pool for (tokenIn, tokenOut) must exist in the AMM factory\n     * - amountIn > 0\n     * - deadline not expired\n     * - minAmountOut is respected (slippage protection)\n     * - Either tokenIn or tokenOut should typically be USDC/EURC for stablecoin-centric swaps\n     */\n    function swapLocal(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient,\n        uint256 deadline\n    ) external returns (uint256 amountOut) {\n        require(recipient != address(0), \"RECIPIENT_ZERO\");\n        require(amountIn > 0, \"AMOUNT_ZERO\");\n        require(block.timestamp <= deadline, \"EXPIRED\");\n        require(tokenIn != tokenOut, \"SAME_TOKEN\");\n        // Optional: enforce that at least one leg is a supported stablecoin\n        require(\n            tokenIn == address(USDC) ||\n            tokenIn == address(EURC) ||\n            tokenOut == address(USDC) ||\n            tokenOut == address(EURC),\n            \"ONE_LEG_MUST_BE_STABLE\"\n        );\n\n        IERC20 inToken = IERC20(tokenIn);\n\n        // Collect tokens from user and apply protocol fee (if any)\n        (uint256 netAmount, uint256 fee) = _collectAndTakeFee(inToken, amountIn);\n\n        if (fee > 0) {\n            inToken.safeTransfer(feeCollector, fee);\n        }\n\n        // Try vault first (vaults ARE the pools)\n        address vault = address(0);\n        if (address(vaultFactory) != address(0)) {\n            // Check if one token is a project token with a vault\n            if (tokenIn != address(USDC) && tokenIn != address(EURC)) {\n                vault = vaultFactory.getVault(tokenIn);\n            } else if (tokenOut != address(USDC) && tokenOut != address(EURC)) {\n                vault = vaultFactory.getVault(tokenOut);\n            }\n        }\n\n        if (vault != address(0)) {\n            // Use vault as the pool\n            IVault vaultContract = IVault(vault);\n            require(\n                (tokenIn == vaultContract.projectToken() && tokenOut == vaultContract.usdc()) ||\n                (tokenIn == vaultContract.usdc() && tokenOut == vaultContract.projectToken()),\n                \"VAULT_TOKEN_MISMATCH\"\n            );\n            \n            // Reset approval first (required for some tokens like USDC)\n            inToken.approve(vault, 0);\n            // Approve vault to spend tokens from router\n            inToken.approve(vault, netAmount);\n            \n            // Execute swap in vault (vault pulls tokens from router via safeTransferFrom)\n            amountOut = vaultContract.swap(tokenIn, netAmount, minAmountOut, recipient);\n            \n            // Reset approval\n            inToken.approve(vault, 0);\n        } else {\n            // Fall back to AMM factory/pool\n            require(address(ammFactory) != address(0), \"NO_VAULT_OR_POOL\");\n            \n            address pool = ammFactory.getPool(tokenIn, tokenOut);\n            require(pool != address(0), \"NO_POOL\");\n\n            // Forward netAmount of tokenIn to the pool\n            inToken.safeTransfer(pool, netAmount);\n\n            // Execute swap in the pool; pool is responsible for sending tokenOut to `recipient`\n            amountOut = IArcAMMPool(pool).swap(tokenIn, tokenOut, netAmount, recipient);\n        }\n\n        require(amountOut >= minAmountOut, \"SLIPPAGE\");\n\n        emit LocalSwap(msg.sender, tokenIn, tokenOut, amountIn, amountOut, recipient);\n    }\n\n    /**\n     * CCTP route: burns USDC on Arc and emits a cross-chain message\n     * to mint on destination chain.\n     *\n     * Frontend / backend should be using Bridge Kit to discover domains,\n     * do quoting, etc. – this contract just wraps the onchain interaction.\n     *\n     * @param destinationDomain CCTP destination domain ID (NOT EVM chainId)\n     * @param mintRecipient     32-byte recipient address on destination chain\n     * @param amount            amount of USDC to send (pre-fee)\n     * @param useHook           true to use depositForBurnWithHook, false to use depositForBurn\n     * @param destinationCaller optional destination caller (if using hook)\n     * @param maxFee            max fee for fast burn (CCTP V2, if enabled)\n     * @param minFinality       min finality threshold (CCTP V2)\n     * @param hookData          arbitrary hook payload to deliver to destination\n     */\n    function routeCCTP(\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        uint256 amount,\n        bool useHook,\n        bytes32 destinationCaller,\n        uint256 maxFee,\n        uint32 minFinality,\n        bytes calldata hookData\n    ) external returns (uint64 nonce) {\n        require(amount > 0, \"AMOUNT_ZERO\");\n        require(mintRecipient != bytes32(0), \"MINT_RECIPIENT_ZERO\");\n\n        IERC20 token = USDC; // for now we assume USDC only; EURC could be added if/when supported\n\n        (uint256 netAmount, uint256 fee) = _collectAndTakeFee(token, amount);\n\n        if (fee > 0) {\n            token.safeTransfer(feeCollector, fee);\n        }\n\n        // Approve TokenMessenger to burn netAmount USDC\n        token.approve(address(tokenMessenger), 0); // reset\n        token.approve(address(tokenMessenger), netAmount);\n\n        if (useHook) {\n            nonce = tokenMessenger.depositForBurnWithHook(\n                netAmount,\n                destinationDomain,\n                mintRecipient,\n                address(token),\n                destinationCaller,\n                maxFee,\n                minFinality,\n                hookData\n            );\n        } else {\n            nonce = tokenMessenger.depositForBurn(\n                netAmount,\n                destinationDomain,\n                mintRecipient,\n                address(token)\n            );\n        }\n\n        emit CCTPTransferInitiated(\n            msg.sender,\n            address(token),\n            netAmount,\n            destinationDomain,\n            mintRecipient,\n            nonce,\n            hookData\n        );\n    }\n\n    /**\n     * Gateway route: deposit USDC (or EURC if supported) into Circle Gateway Wallet.\n     *\n     * This establishes / tops up the user's unified balance in Gateway.\n     * Your backend then uses the Gateway API to mint on destination chains.\n     * \n     * NOTE: Gateway operations must involve Arc (deposit from Arc or withdraw to Arc).\n     */\n    function routeGatewayDeposit(\n        address token,\n        uint256 amount,\n        address depositor,\n        bool useDepositFor\n    ) external {\n        require(amount > 0, \"AMOUNT_ZERO\");\n        _checkSupportedToken(token);\n        if (depositor == address(0)) depositor = msg.sender;\n\n        IERC20 erc20 = IERC20(token);\n\n        (uint256 netAmount, uint256 fee) = _collectAndTakeFee(erc20, amount);\n\n        if (fee > 0) {\n            erc20.safeTransfer(feeCollector, fee);\n        }\n\n        // Approve GatewayWallet to take tokens\n        erc20.approve(address(gatewayWallet), 0);\n        erc20.approve(address(gatewayWallet), netAmount);\n\n        if (useDepositFor) {\n            gatewayWallet.depositFor(token, depositor, netAmount);\n        } else {\n            // depositor is ignored in this branch; msg.sender becomes depositor in Gateway\n            gatewayWallet.deposit(token, netAmount);\n        }\n\n        emit GatewayDeposit(msg.sender, depositor, token, netAmount);\n    }\n\n    /**\n     * Receive CCTP message callback (can be used in hooks)\n     * This function can be called by MessageTransmitter after receiving a CCTP message\n     * to route the minted USDC to a specific recipient or execute additional logic.\n     * \n     * NOTE: This is optional - CCTP messages can mint directly to recipients.\n     * This function is useful if you want the router to handle the minted tokens.\n     * \n     * @param recipient Address to receive the minted USDC\n     * @param amount Amount of USDC that was minted\n     */\n    function onCCTPReceived(\n        address recipient,\n        uint256 amount\n    ) external {\n        // This function can be called by MessageTransmitter via hook\n        // or can be used to route minted USDC from this contract to recipients\n        // For now, it's a placeholder - actual implementation depends on hook setup\n        \n        // If USDC was minted to this contract, we can route it\n        uint256 balance = USDC.balanceOf(address(this));\n        if (balance >= amount && recipient != address(0)) {\n            USDC.safeTransfer(recipient, amount);\n        }\n    }\n\n    // ========= Views / helpers =========\n\n    function previewFee(uint256 amount) public view returns (uint256) {\n        if (feeBps == 0) return 0;\n        return (amount * feeBps) / 10_000;\n    }\n\n    function _collectAndTakeFee(IERC20 token, uint256 amount)\n        internal\n        returns (uint256 netAmount, uint256 fee)\n    {\n        fee = previewFee(amount);\n        netAmount = amount - fee;\n\n        token.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function _checkSupportedToken(address token) internal view {\n        require(\n            token == address(USDC) || token == address(EURC),\n            \"UNSUPPORTED_TOKEN\"\n        );\n    }\n}\n\n/**\n * Lightweight SafeTransfer library to avoid full OZ dependency.\n * If you’re already using OZ, replace with SafeERC20.\n */\nlibrary SafeTransfer {\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        bool ok = token.transfer(to, value);\n        require(ok, \"TRANSFER_FAILED\");\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        bool ok = token.transferFrom(from, to, value);\n        require(ok, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        bool ok = token.approve(spender, value);\n        require(ok, \"APPROVE_FAILED\");\n    }\n}"
      },
      "project/core/FluxaGateway.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {WrappedToken} from \"./WrappedToken.sol\";\n\n/**\n * @title ILiquidityVault\n * @notice Interface for vault liquidity management\n */\ninterface ILiquidityVault {\n    function withdrawForAggregation(uint32 destinationChain) external returns (uint256, uint256);\n    function returnLiquidity(uint256 projectTokenAmount, uint256 usdcAmount) external;\n}\n\n/**\n * @title FluxaGateway\n * @notice Simplified Gateway protocol for hackathon - Backend-assisted token bridging to Arc\n * \n * Simplified Architecture (Hackathon Version):\n * - Arc is the ONLY destination (all tokens flow TO Arc)\n * - Other chains (Base, Polygon, etc.) are ONLY sources (tokens flow FROM them)\n * - Backend server acts as trusted intermediary/relay\n * - No LayerZero - backend monitors events and triggers mints\n * \n * Flow:\n * 1. User deposits tokens on source chain (Base, Polygon, etc.) → Gateway locks tokens\n * 2. Backend monitors TokenDeposited event\n * 3. Backend calls mintWrapped() on Arc Gateway to mint wrapped tokens\n * 4. User receives wrapped tokens on Arc\n * \n * Security Model (Hackathon):\n * - Backend wallet is trusted to relay messages correctly\n * - Source chains: Normal contracts that lock tokens (no minting)\n * - Arc chain: Can only mint when backend calls mintWrapped() with valid signature\n * - Nonce system: Prevents replay attacks\n * \n * @dev This is a simplified version for hackathon. Production would use LayerZero or similar.\n */\ncontract FluxaGateway is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // ============================================================================\n    // State Variables\n    // ============================================================================\n\n    /// @notice The token being wrapped (on source chain) or wrapped token contract (on Arc)\n    address public immutable token;\n\n    /// @notice Whether this is a source chain (locks tokens) or Arc (mints wrapped)\n    bool public immutable isSource;\n\n    /// @notice Chain ID of this chain\n    uint32 public immutable chainId;\n\n    /// @notice Backend coordinator address (trusted relay)\n    address public coordinator;\n\n    /// @notice Total tokens locked on source chain (backing all wrapped tokens)\n    uint256 public totalLocked;\n\n    /// @notice Total wrapped tokens minted on Arc (per source chain)\n    mapping(uint32 => uint256) public totalWrapped;\n\n    /// @notice Nonce counter for deposits (per destination chain)\n    mapping(uint32 => uint256) public depositNonces;\n\n    /// @notice Nonce counter for burns (per origin chain)\n    mapping(uint32 => uint256) public burnNonces;\n\n    /// @notice Mapping: (sourceChain, nonce) => processed\n    mapping(uint32 => mapping(uint256 => bool)) public processedNonces;\n\n    /// @notice Wrapped token contract (on destination chain with wrapped tokens)\n    address public wrappedToken;\n\n    /// @notice USDC aggregator wallet address for cross-chain bridging\n    address public immutable usdcAggregator;\n\n    /// @notice Liquidity vault address on this chain\n    address public vault;\n\n    /// @notice USDC token address on this chain\n    address public immutable usdc;\n\n    // ============================================================================\n    // Pending Transaction Queue (for backend processing)\n    // ============================================================================\n\n    struct PendingDeposit {\n        uint32 sourceChain;\n        address recipient;\n        uint256 amount;\n        uint256 nonce;\n        uint256 timestamp;\n        uint256 priorityFee; // FLX tokens paid for faster processing\n        bool processed;\n    }\n\n    struct PendingBurn {\n        uint32 destChain;\n        address recipient;\n        uint256 amount;\n        uint256 nonce;\n        uint256 timestamp;\n        uint256 priorityFee; // FLX tokens paid for faster processing\n        bool processed;\n    }\n\n    /// @notice Queue of pending deposits to be processed by coordinator\n    PendingDeposit[] public pendingDeposits;\n\n    /// @notice Queue of pending burns to be processed by coordinator\n    PendingBurn[] public pendingBurns;\n\n    /// @notice Minimum time before a pending item can be processed (safety delay)\n    uint256 public constant PROCESSING_DELAY = 10; // 10 seconds\n\n    /// @notice Accumulated priority fees (in FLX tokens)\n    uint256 public accumulatedFees;\n\n    // ============================================================================\n    // Events\n    // ============================================================================\n\n    event TokenDeposited(\n        address indexed depositor,\n        uint256 amount,\n        uint32 sourceChain,\n        uint32 destinationChain, // Always Arc\n        address destinationRecipient,\n        uint256 nonce\n    );\n\n    event WrappedTokensMinted(\n        uint32 indexed sourceChain,\n        address indexed recipient,\n        uint256 amount,\n        uint256 nonce\n    );\n\n    event WrappedTokensBurned(\n        address indexed burner,\n        uint256 amount,\n        uint32 destinationChain,\n        uint32 originChain,\n        address originRecipient,\n        uint256 nonce\n    );\n\n    event TokensReleased(\n        uint32 indexed sourceChain,\n        address indexed recipient,\n        uint256 amount,\n        uint256 nonce\n    );\n\n    event CoordinatorUpdated(address indexed oldCoordinator, address indexed newCoordinator);\n    event WrappedTokenUpdated(address indexed wrappedToken);\n    event VaultSet(address indexed vault);\n    event LiquidityAggregationInitiated(uint32 indexed destChain, uint256 flxAmount, uint256 usdcAmount);\n    event LiquidityRepopulated(uint256 flxAmount, uint256 usdcAmount);\n\n    // ============================================================================\n    // Modifiers\n    // ============================================================================\n\n    modifier onlyCoordinator() {\n        require(msg.sender == coordinator, \"ONLY_COORDINATOR\");\n        _;\n    }\n\n    // ============================================================================\n    // Constructor\n    // ============================================================================\n\n    constructor(\n        address _token,\n        bool _isSource,\n        uint32 _chainId,\n        address _coordinator,\n        address _usdcAggregator,\n        address _usdc\n    ) Ownable(msg.sender) {\n        require(_token != address(0), \"ZERO_TOKEN\");\n        require(_coordinator != address(0), \"ZERO_COORDINATOR\");\n        require(_usdc != address(0), \"ZERO_USDC\");\n        \n        token = _token;\n        isSource = _isSource;\n        chainId = _chainId;\n        coordinator = _coordinator;\n        usdcAggregator = _usdcAggregator; // Can be address(0) initially\n        usdc = _usdc;\n    }\n\n    // ============================================================================\n    // Admin Functions\n    // ============================================================================\n\n    /**\n     * @notice Update coordinator address (backend relay wallet)\n     */\n    function setCoordinator(address _coordinator) external onlyOwner {\n        require(_coordinator != address(0), \"ZERO_ADDRESS\");\n        address oldCoordinator = coordinator;\n        coordinator = _coordinator;\n        emit CoordinatorUpdated(oldCoordinator, _coordinator);\n    }\n\n    /**\n     * @notice Set wrapped token contract (Arc only)\n     */\n    function setWrappedToken(address _wrappedToken) external onlyOwner {\n        require(!isSource, \"SOURCE_NO_WRAPPED\");\n        require(_wrappedToken != address(0), \"ZERO_ADDRESS\");\n        wrappedToken = _wrappedToken;\n        emit WrappedTokenUpdated(_wrappedToken);\n    }\n\n    // ============================================================================\n    // Vault Management Functions - CROSS-CHAIN LIQUIDITY AGGREGATION\n    // ============================================================================\n\n    /**\n     * @notice Set vault address for this chain\n     * @param _vault Address of the liquidity vault\n     */\n    function setVault(address _vault) external onlyOwner {\n        require(_vault != address(0), \"ZERO_VAULT\");\n        vault = _vault;\n        emit VaultSet(_vault);\n    }\n\n    /**\n     * @notice Aggregate liquidity from vault for cross-chain swap\n     * @dev Only coordinator can call this to initiate cross-chain aggregation\n     * @param destChain Destination chain ID where liquidity is being aggregated\n     * @return flxAmount Amount of FLX/wFLX withdrawn\n     * @return usdcAmount Amount of USDC withdrawn\n     */\n    function aggregateLiquidity(uint32 destChain) \n        external \n        onlyCoordinator\n        nonReentrant \n        returns (uint256 flxAmount, uint256 usdcAmount) \n    {\n        require(vault != address(0), \"NO_VAULT\");\n        \n        // Call vault to withdraw all liquidity\n        (flxAmount, usdcAmount) = ILiquidityVault(vault).withdrawForAggregation(destChain);\n        \n        // If this is Base (source chain with wFLX), burn wFLX to unlock FLX on Arc\n        if (isSource && wrappedToken != address(0)) {\n            // wFLX is already in this contract, will be burned via normal flow\n            // Backend will process this as deposit to Arc\n        }\n        \n        // Send USDC to aggregator wallet for CCTP bridging\n        if (usdcAmount > 0 && usdcAggregator != address(0)) {\n            IERC20(usdc).safeTransfer(usdcAggregator, usdcAmount);\n        }\n        \n        emit LiquidityAggregationInitiated(destChain, flxAmount, usdcAmount);\n        \n        return (flxAmount, usdcAmount);\n    }\n\n    /**\n     * @notice Return liquidity to vault after cross-chain swap\n     * @dev Only coordinator can call this to return liquidity with new proportions\n     * @param flxAmount Amount of FLX/wFLX to return\n     * @param usdcAmount Amount of USDC to return\n     */\n    function repopulateVault(uint256 flxAmount, uint256 usdcAmount) \n        external \n        onlyCoordinator\n        nonReentrant \n    {\n        require(vault != address(0), \"NO_VAULT\");\n        \n        // Approve vault to pull tokens\n        if (flxAmount > 0) {\n            IERC20(token).safeIncreaseAllowance(vault, flxAmount);\n        }\n        if (usdcAmount > 0) {\n            IERC20(usdc).safeIncreaseAllowance(vault, usdcAmount);\n        }\n        \n        // Call vault to return liquidity\n        ILiquidityVault(vault).returnLiquidity(flxAmount, usdcAmount);\n        \n        emit LiquidityRepopulated(flxAmount, usdcAmount);\n    }\n\n    // ============================================================================\n    // Source Chain Functions (Deposit)\n    // ============================================================================\n\n    /**\n     * @notice Deposit tokens to be wrapped on destination chain\n     * @param amount Amount of tokens to deposit\n     * @param destinationChain Chain ID where wrapped tokens will be minted\n     * @param destinationRecipient Address to receive wrapped tokens on destination\n     * @param priorityFee Optional FLX tokens to pay for faster processing (higher = faster)\n     */\n    function depositForWrap(\n        uint256 amount,\n        uint32 destinationChain,\n        address destinationRecipient,\n        uint256 priorityFee\n    ) external nonReentrant returns (uint256 nonce) {\n        require(isSource, \"NOT_SOURCE\");\n        require(amount > 0, \"ZERO_AMOUNT\");\n        require(destinationChain != 0, \"ZERO_CHAIN\");\n        require(destinationRecipient != address(0), \"ZERO_RECIPIENT\");\n\n        // Transfer tokens from user (amount + priority fee)\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount + priorityFee);\n        \n        // Update locked balance (only the actual amount, not the fee)\n        totalLocked += amount;\n        \n        // Accumulate priority fee\n        if (priorityFee > 0) {\n            accumulatedFees += priorityFee;\n        }\n\n        // Increment nonce for this destination chain\n        nonce = depositNonces[destinationChain]++;\n        \n        // Add to pending queue for coordinator to process\n        pendingDeposits.push(PendingDeposit({\n            sourceChain: chainId,\n            recipient: destinationRecipient,\n            amount: amount,\n            nonce: nonce,\n            timestamp: block.timestamp,\n            priorityFee: priorityFee,\n            processed: false\n        }));\n        \n        emit TokenDeposited(\n            msg.sender,\n            amount,\n            chainId, // Source chain (this chain)\n            destinationChain, // Destination chain (Base, Arc, etc.)\n            destinationRecipient,\n            nonce\n        );\n\n        return nonce;\n    }\n\n    // ============================================================================\n    // Arc Chain Functions (Mint)\n    // ============================================================================\n\n    /**\n     * @notice Mint wrapped tokens on Arc (called by backend coordinator)\n     * @param sourceChain Chain ID where tokens were deposited\n     * @param recipient Address to receive wrapped tokens\n     * @param amount Amount of wrapped tokens to mint\n     * @param nonce Nonce from the deposit message\n     */\n    function mintWrapped(\n        uint32 sourceChain,\n        address recipient,\n        uint256 amount,\n        uint256 nonce\n    ) external nonReentrant onlyCoordinator {\n        require(!isSource, \"NOT_ARC\");\n        require(amount > 0, \"ZERO_AMOUNT\");\n        require(recipient != address(0), \"ZERO_RECIPIENT\");\n        require(!processedNonces[sourceChain][nonce], \"ALREADY_PROCESSED\");\n        require(wrappedToken != address(0), \"NO_WRAPPED_TOKEN\");\n\n        // Mark nonce as processed\n        processedNonces[sourceChain][nonce] = true;\n\n        // Update wrapped total\n        totalWrapped[sourceChain] += amount;\n\n        // Mint wrapped tokens\n        WrappedToken(wrappedToken).mint(recipient, amount);\n\n        emit WrappedTokensMinted(sourceChain, recipient, amount, nonce);\n    }\n\n    // ============================================================================\n    // Destination Chain Functions (Burn wrapped tokens)\n    // ============================================================================\n\n    /**\n     * @notice Burn wrapped tokens to unwrap on origin chain\n     * @param amount Amount of wrapped tokens to burn\n     * @param originChain Chain ID where real tokens will be released\n     * @param originRecipient Address to receive real tokens on origin chain\n     * @param priorityFee Optional wFLX tokens to pay for faster processing (higher = faster)\n     */\n    function burnForUnwrap(\n        uint256 amount,\n        uint32 originChain,\n        address originRecipient,\n        uint256 priorityFee\n    ) external nonReentrant returns (uint256 nonce) {\n        require(!isSource, \"NOT_DESTINATION\");\n        require(amount > 0, \"ZERO_AMOUNT\");\n        require(originChain != 0, \"ZERO_CHAIN\");\n        require(originRecipient != address(0), \"ZERO_RECIPIENT\");\n        require(wrappedToken != address(0), \"NO_WRAPPED_TOKEN\");\n\n        // Burn wrapped tokens from user\n        WrappedToken(wrappedToken).burn(msg.sender, amount);\n        \n        // If priority fee provided, burn it as well (fees collected in wFLX on destination)\n        if (priorityFee > 0) {\n            WrappedToken(wrappedToken).burn(msg.sender, priorityFee);\n            accumulatedFees += priorityFee;\n        }\n\n        // Update wrapped total\n        require(totalWrapped[originChain] >= amount, \"INSUFFICIENT_WRAPPED\");\n        totalWrapped[originChain] -= amount;\n\n        // Increment nonce for this origin chain\n        nonce = burnNonces[originChain]++;\n\n        // Add to pending queue for coordinator to process\n        pendingBurns.push(PendingBurn({\n            destChain: chainId,\n            recipient: originRecipient,\n            amount: amount,\n            nonce: nonce,\n            timestamp: block.timestamp,\n            priorityFee: priorityFee,\n            processed: false\n        }));\n        \n        emit WrappedTokensBurned(\n            msg.sender,\n            amount,\n            chainId, // Current chain (destination)\n            originChain, // Origin chain where tokens will be released\n            originRecipient,\n            nonce\n        );\n\n        return nonce;\n    }\n\n    // ============================================================================\n    // Source Chain Functions (Release tokens after burn)\n    // ============================================================================\n\n    /**\n     * @notice Release tokens on source chain (called by backend coordinator after burn)\n     * @param destChain Chain ID where tokens were burned\n     * @param recipient Address to receive tokens\n     * @param amount Amount of tokens to release\n     * @param nonce Nonce from the burn message\n     */\n    function releaseTokens(\n        uint32 destChain,\n        address recipient,\n        uint256 amount,\n        uint256 nonce\n    ) external nonReentrant onlyCoordinator {\n        require(isSource, \"NOT_SOURCE\");\n        require(amount > 0, \"ZERO_AMOUNT\");\n        require(recipient != address(0), \"ZERO_RECIPIENT\");\n        require(!processedNonces[destChain][nonce], \"ALREADY_PROCESSED\");\n        require(totalLocked >= amount, \"INSUFFICIENT_LOCKED\");\n\n        // Mark nonce as processed\n        processedNonces[destChain][nonce] = true;\n\n        // Update locked balance\n        totalLocked -= amount;\n\n        // Transfer tokens to recipient\n        IERC20(token).safeTransfer(recipient, amount);\n\n        emit TokensReleased(destChain, recipient, amount, nonce);\n    }\n\n    // ============================================================================\n    // Queue Processing Functions (\"Shake\" functions for coordinator)\n    // ============================================================================\n\n    /**\n     * @notice Get pending deposits ready for processing (sorted by priority fee, highest first)\n     * @dev Called by coordinator to \"shake\" the queue and get ready items\n     */\n    function processPendingDepositsInfo() external view returns (\n        uint256[] memory readyIndices,\n        uint32[] memory sourceChains,\n        address[] memory recipients,\n        uint256[] memory amounts,\n        uint256[] memory nonces,\n        uint256[] memory priorityFees\n    ) {\n        // Count ready items\n        uint256 readyCount = 0;\n        for (uint256 i = 0; i < pendingDeposits.length; i++) {\n            if (!pendingDeposits[i].processed && \n                block.timestamp >= pendingDeposits[i].timestamp + PROCESSING_DELAY) {\n                readyCount++;\n            }\n        }\n\n        // Allocate arrays\n        readyIndices = new uint256[](readyCount);\n        sourceChains = new uint32[](readyCount);\n        recipients = new address[](readyCount);\n        amounts = new uint256[](readyCount);\n        nonces = new uint256[](readyCount);\n        priorityFees = new uint256[](readyCount);\n\n        // Fill arrays (unsorted)\n        uint256 j = 0;\n        for (uint256 i = 0; i < pendingDeposits.length; i++) {\n            if (!pendingDeposits[i].processed && \n                block.timestamp >= pendingDeposits[i].timestamp + PROCESSING_DELAY) {\n                readyIndices[j] = i;\n                sourceChains[j] = pendingDeposits[i].sourceChain;\n                recipients[j] = pendingDeposits[i].recipient;\n                amounts[j] = pendingDeposits[i].amount;\n                nonces[j] = pendingDeposits[i].nonce;\n                priorityFees[j] = pendingDeposits[i].priorityFee;\n                j++;\n            }\n        }\n\n        // Sort by priority fee (highest first) using simple bubble sort\n        for (uint256 i = 0; i < readyCount; i++) {\n            for (uint256 k = i + 1; k < readyCount; k++) {\n                if (priorityFees[k] > priorityFees[i]) {\n                    // Swap all arrays\n                    (readyIndices[i], readyIndices[k]) = (readyIndices[k], readyIndices[i]);\n                    (sourceChains[i], sourceChains[k]) = (sourceChains[k], sourceChains[i]);\n                    (recipients[i], recipients[k]) = (recipients[k], recipients[i]);\n                    (amounts[i], amounts[k]) = (amounts[k], amounts[i]);\n                    (nonces[i], nonces[k]) = (nonces[k], nonces[i]);\n                    (priorityFees[i], priorityFees[k]) = (priorityFees[k], priorityFees[i]);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Mark deposits as processed after coordinator mints them\n     * @param indices Array of indices to mark as processed\n     */\n    function markDepositsProcessed(uint256[] calldata indices) external onlyCoordinator {\n        for (uint256 i = 0; i < indices.length; i++) {\n            require(indices[i] < pendingDeposits.length, \"INVALID_INDEX\");\n            pendingDeposits[indices[i]].processed = true;\n        }\n    }\n\n    /**\n     * @notice Get pending burns ready for processing (sorted by priority fee, highest first)\n     * @dev Called by coordinator to get burns that need token release\n     */\n    function processPendingBurnsInfo() external view returns (\n        uint256[] memory readyIndices,\n        uint32[] memory destChains,\n        address[] memory recipients,\n        uint256[] memory amounts,\n        uint256[] memory nonces,\n        uint256[] memory priorityFees\n    ) {\n        // Count ready items\n        uint256 readyCount = 0;\n        for (uint256 i = 0; i < pendingBurns.length; i++) {\n            if (!pendingBurns[i].processed && \n                block.timestamp >= pendingBurns[i].timestamp + PROCESSING_DELAY) {\n                readyCount++;\n            }\n        }\n\n        // Allocate arrays\n        readyIndices = new uint256[](readyCount);\n        destChains = new uint32[](readyCount);\n        recipients = new address[](readyCount);\n        amounts = new uint256[](readyCount);\n        nonces = new uint256[](readyCount);\n        priorityFees = new uint256[](readyCount);\n\n        // Fill arrays (unsorted)\n        uint256 j = 0;\n        for (uint256 i = 0; i < pendingBurns.length; i++) {\n            if (!pendingBurns[i].processed && \n                block.timestamp >= pendingBurns[i].timestamp + PROCESSING_DELAY) {\n                readyIndices[j] = i;\n                destChains[j] = pendingBurns[i].destChain;\n                recipients[j] = pendingBurns[i].recipient;\n                amounts[j] = pendingBurns[i].amount;\n                nonces[j] = pendingBurns[i].nonce;\n                priorityFees[j] = pendingBurns[i].priorityFee;\n                j++;\n            }\n        }\n\n        // Sort by priority fee (highest first) using simple bubble sort\n        for (uint256 i = 0; i < readyCount; i++) {\n            for (uint256 k = i + 1; k < readyCount; k++) {\n                if (priorityFees[k] > priorityFees[i]) {\n                    // Swap all arrays\n                    (readyIndices[i], readyIndices[k]) = (readyIndices[k], readyIndices[i]);\n                    (destChains[i], destChains[k]) = (destChains[k], destChains[i]);\n                    (recipients[i], recipients[k]) = (recipients[k], recipients[i]);\n                    (amounts[i], amounts[k]) = (amounts[k], amounts[i]);\n                    (nonces[i], nonces[k]) = (nonces[k], nonces[i]);\n                    (priorityFees[i], priorityFees[k]) = (priorityFees[k], priorityFees[i]);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Mark burns as processed after coordinator releases tokens\n     * @param indices Array of indices to mark as processed\n     */\n    function markBurnsProcessed(uint256[] calldata indices) external onlyCoordinator {\n        for (uint256 i = 0; i < indices.length; i++) {\n            require(indices[i] < pendingBurns.length, \"INVALID_INDEX\");\n            pendingBurns[indices[i]].processed = true;\n        }\n    }\n\n    // ============================================================================\n    // View Functions\n    // ============================================================================\n\n    function getTotalLocked() external view returns (uint256) {\n        return totalLocked;\n    }\n\n    function getPendingDepositsCount() external view returns (uint256) {\n        return pendingDeposits.length;\n    }\n\n    function getPendingBurnsCount() external view returns (uint256) {\n        return pendingBurns.length;\n    }\n\n    function getTotalWrapped(uint32 sourceChain) external view returns (uint256) {\n        return totalWrapped[sourceChain];\n    }\n\n    function getAccumulatedFees() external view returns (uint256) {\n        return accumulatedFees;\n    }\n\n    // ============================================================================\n    // Admin Functions\n    // ============================================================================\n\n    /**\n     * @notice Withdraw accumulated priority fees\n     * @param recipient Address to receive the fees\n     * @param amount Amount to withdraw (must be <= accumulatedFees)\n     */\n    function withdrawFees(address recipient, uint256 amount) external onlyOwner {\n        require(recipient != address(0), \"ZERO_RECIPIENT\");\n        require(amount > 0 && amount <= accumulatedFees, \"INVALID_AMOUNT\");\n        \n        accumulatedFees -= amount;\n        IERC20(token).safeTransfer(recipient, amount);\n    }\n\n    function isNonceProcessed(uint32 sourceChain, uint256 nonce) external view returns (bool) {\n        return processedNonces[sourceChain][nonce];\n    }\n\n    function getDepositNonce(uint32 destChain) external view returns (uint256) {\n        return depositNonces[destChain];\n    }\n}\n"
      },
      "project/core/FluxaSwapRouter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title FluxaSwapRouter\n * @notice User-facing swap router that always settles on the same chain\n * \n * Key Constraint: Users always start and finish on the same chain.\n * Cross-chain routing is purely internal for better execution.\n * \n * Architecture:\n * - User calls swap() on their chain (e.g., Base)\n * - Router can execute locally OR route via Arc (internal)\n * - Results always go back to user on the same chain\n * \n * Flow:\n * 1. User swaps FLX → USDC on Base\n * 2. Router decides: LOCAL_ONLY or VIA_ARC\n * 3. If LOCAL_ONLY: Swap on Base pools, send result to user\n * 4. If VIA_ARC: Lock assets, send LZ message to Arc, Arc executes, Arc sends back, Router credits user\n * 5. User receives USDC on Base (same chain they started)\n */\ncontract FluxaSwapRouter is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // ============================================================================\n    // State Variables\n    // ============================================================================\n\n    /// @notice Local AMM/Vault for executing swaps on this chain\n    address public localPool;\n\n    /// @notice Arc Router address (for routing via Arc)\n    address public arcRouter;\n\n    /// @notice LayerZero Endpoint (for cross-chain messages)\n    address public lzEndpoint;\n\n    /// @notice Chain ID of this chain\n    uint32 public immutable chainId;\n\n    /// @notice Arc chain ID\n    uint32 public constant ARC_CHAIN_ID = 5042002;\n\n    /// @notice Pending swap requests (requestId => SwapRequest)\n    mapping(bytes32 => SwapRequest) public pendingSwaps;\n\n    /// @notice Request ID counter\n    uint256 public requestIdCounter;\n\n    // ============================================================================\n    // Structs\n    // ============================================================================\n\n    enum SwapStrategy {\n        LOCAL_ONLY,  // Execute swap on local chain only\n        VIA_ARC      // Route via Arc for better execution\n    }\n\n    struct SwapRequest {\n        address user;\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint256 minAmountOut;\n        SwapStrategy strategy;\n        bool completed;\n    }\n\n    struct RoutePlan {\n        bytes32 requestId;\n        address user;\n        uint32 userChainId;\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint256 minAmountOut;\n        bool useArc;\n    }\n\n    // ============================================================================\n    // Events\n    // ============================================================================\n\n    event SwapRequested(\n        bytes32 indexed requestId,\n        address indexed user,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 minAmountOut\n    );\n\n    event SwapExecuted(\n        bytes32 indexed requestId,\n        address indexed user,\n        address tokenOut,\n        uint256 amountOut,\n        SwapStrategy strategy\n    );\n\n    event ArcSwapInitiated(\n        bytes32 indexed requestId,\n        address indexed user,\n        uint32 arcChainId\n    );\n\n    event ArcSwapCompleted(\n        bytes32 indexed requestId,\n        address indexed user,\n        address tokenOut,\n        uint256 amountOut\n    );\n\n    // ============================================================================\n    // Constructor\n    // ============================================================================\n\n    constructor(\n        address _localPool,\n        address _arcRouter,\n        address _lzEndpoint,\n        uint32 _chainId\n    ) Ownable(msg.sender) {\n        require(_localPool != address(0), \"ZERO_POOL\");\n        require(_lzEndpoint != address(0), \"ZERO_ENDPOINT\");\n        \n        localPool = _localPool;\n        arcRouter = _arcRouter;\n        lzEndpoint = _lzEndpoint;\n        chainId = _chainId;\n    }\n\n    // ============================================================================\n    // User-Facing Functions\n    // ============================================================================\n\n    /**\n     * @notice User initiates a swap (always on their chain)\n     * @param tokenIn Token to swap from\n     * @param tokenOut Token to swap to\n     * @param amountIn Amount of tokenIn to swap\n     * @param minAmountOut Minimum amount of tokenOut expected\n     * @return requestId Unique identifier for this swap request\n     */\n    function swap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 minAmountOut\n    ) external nonReentrant returns (bytes32 requestId) {\n        require(tokenIn != address(0) && tokenOut != address(0), \"ZERO_TOKEN\");\n        require(amountIn > 0, \"ZERO_AMOUNT\");\n        require(tokenIn != tokenOut, \"SAME_TOKEN\");\n\n        // Generate request ID\n        requestId = keccak256(abi.encodePacked(\n            block.timestamp,\n            block.number,\n            msg.sender,\n            requestIdCounter++\n        ));\n\n        // Transfer tokens from user\n        IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n\n        // Store swap request\n        pendingSwaps[requestId] = SwapRequest({\n            user: msg.sender,\n            tokenIn: tokenIn,\n            tokenOut: tokenOut,\n            amountIn: amountIn,\n            minAmountOut: minAmountOut,\n            strategy: SwapStrategy.LOCAL_ONLY, // Will be updated by backend\n            completed: false\n        });\n\n        emit SwapRequested(requestId, msg.sender, tokenIn, tokenOut, amountIn, minAmountOut);\n\n        // For now, execute locally (backend will call confirmRouteAndSend for Arc routing)\n        // In production, you might want to do a quick local check first\n        _executeLocalSwap(requestId);\n    }\n\n    /**\n     * @notice Backend confirms routing strategy and executes\n     * @dev Called by backend after analyzing LP depths\n     * @param requestId Swap request ID\n     * @param routePlan Routing plan (LOCAL_ONLY or VIA_ARC)\n     */\n    function confirmRouteAndSend(\n        bytes32 requestId,\n        RoutePlan calldata routePlan\n    ) external onlyOwner nonReentrant {\n        SwapRequest storage swapReq = pendingSwaps[requestId];\n        require(swapReq.user != address(0), \"INVALID_REQUEST\");\n        require(!swapReq.completed, \"ALREADY_COMPLETED\");\n        require(routePlan.userChainId == chainId, \"WRONG_CHAIN\");\n\n        // Update strategy\n        swapReq.strategy = routePlan.useArc ? SwapStrategy.VIA_ARC : SwapStrategy.LOCAL_ONLY;\n\n        if (routePlan.useArc) {\n            _executeViaArc(requestId, routePlan);\n        } else {\n            _executeLocalSwap(requestId);\n        }\n    }\n\n    // ============================================================================\n    // Internal Execution Functions\n    // ============================================================================\n\n    /**\n     * @notice Execute swap locally on this chain\n     */\n    function _executeLocalSwap(bytes32 requestId) internal {\n        SwapRequest storage swapReq = pendingSwaps[requestId];\n        require(!swapReq.completed, \"ALREADY_COMPLETED\");\n\n        // Approve local pool\n        IERC20(swapReq.tokenIn).approve(localPool, swapReq.amountIn);\n\n        // Execute swap on local pool\n        // Assuming localPool has a swap() function\n        // This would be your LiquidityVault or ArcAMMPool\n        (bool success, bytes memory data) = localPool.call(\n            abi.encodeWithSignature(\n                \"swap(address,address,uint256,uint256,address)\",\n                swapReq.tokenIn,\n                swapReq.tokenOut,\n                swapReq.amountIn,\n                swapReq.minAmountOut,\n                swapReq.user\n            )\n        );\n\n        require(success, \"SWAP_FAILED\");\n        \n        // Decode amountOut from return data (implementation depends on pool interface)\n        uint256 amountOut = abi.decode(data, (uint256));\n        require(amountOut >= swapReq.minAmountOut, \"SLIPPAGE\");\n\n        swapReq.completed = true;\n\n        emit SwapExecuted(requestId, swapReq.user, swapReq.tokenOut, amountOut, SwapStrategy.LOCAL_ONLY);\n    }\n\n    /**\n     * @notice Execute swap via Arc (internal routing)\n     */\n    function _executeViaArc(bytes32 requestId, RoutePlan calldata routePlan) internal {\n        SwapRequest storage swapReq = pendingSwaps[requestId];\n\n        // Lock/burn tokens on this chain\n        // For FLX: burn wrapped version\n        // For USDC: lock or use CCTP\n        IERC20(swapReq.tokenIn).safeTransfer(address(this), swapReq.amountIn);\n\n        // Send LayerZero message to Arc\n        bytes memory payload = abi.encode(routePlan);\n        \n        // This would use LayerZero's send() function\n        // For now, we'll emit an event and let backend handle it\n        // In production, integrate with LayerZero SDK\n        \n        emit ArcSwapInitiated(requestId, swapReq.user, ARC_CHAIN_ID);\n        \n        // Backend will:\n        // 1. Send LZ message to Arc Router\n        // 2. Arc Router executes swap\n        // 3. Arc Router sends result back via LZ\n        // 4. completeArcSwap() is called with result\n    }\n\n    /**\n     * @notice Complete swap after Arc execution (called by LayerZero receive)\n     * @dev This would be called by LayerZero's lzReceive callback\n     */\n    function completeArcSwap(\n        bytes32 requestId,\n        address tokenOut,\n        uint256 amountOut\n    ) external nonReentrant {\n        // In production, verify this is called by LayerZero endpoint\n        // require(msg.sender == lzEndpoint, \"ONLY_LZ\");\n\n        SwapRequest storage swapReq = pendingSwaps[requestId];\n        require(!swapReq.completed, \"ALREADY_COMPLETED\");\n        require(swapReq.tokenOut == tokenOut, \"WRONG_TOKEN\");\n        require(amountOut >= swapReq.minAmountOut, \"SLIPPAGE\");\n\n        // Mint/credit tokens to user on this chain\n        // For USDC: use CCTP mint or unlock\n        // For FLX: mint wrapped version\n        IERC20(tokenOut).safeTransfer(swapReq.user, amountOut);\n\n        swapReq.completed = true;\n\n        emit ArcSwapCompleted(requestId, swapReq.user, tokenOut, amountOut);\n        emit SwapExecuted(requestId, swapReq.user, tokenOut, amountOut, SwapStrategy.VIA_ARC);\n    }\n\n    // ============================================================================\n    // Admin Functions\n    // ============================================================================\n\n    function setLocalPool(address _localPool) external onlyOwner {\n        require(_localPool != address(0), \"ZERO_ADDRESS\");\n        localPool = _localPool;\n    }\n\n    function setArcRouter(address _arcRouter) external onlyOwner {\n        require(_arcRouter != address(0), \"ZERO_ADDRESS\");\n        arcRouter = _arcRouter;\n    }\n\n    function setLZEndpoint(address _lzEndpoint) external onlyOwner {\n        require(_lzEndpoint != address(0), \"ZERO_ADDRESS\");\n        lzEndpoint = _lzEndpoint;\n    }\n\n    // ============================================================================\n    // View Functions\n    // ============================================================================\n\n    function getSwapRequest(bytes32 requestId) external view returns (SwapRequest memory) {\n        return pendingSwaps[requestId];\n    }\n}\n\n"
      },
      "project/core/LiquidityVault.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title LiquidityVault\n * @notice Multi-chain liquidity vault that allows token developers to deposit liquidity\n *         while maintaining withdrawal rights. Governance controls strategy only.\n * @dev Vault mints shares representing proportional ownership. Developers can withdraw\n *      anytime by burning shares. Governance cannot prevent withdrawals or take funds.\n */\ncontract LiquidityVault is ERC20, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    // ============================================================================\n    // State Variables\n    // ============================================================================\n\n    /// @notice The token being paired with USDC (e.g., the project token)\n    address public immutable projectToken;\n\n    /// @notice USDC token address\n    address public immutable usdc;\n\n    /// @notice Governance address with strategy control rights\n    address public governance;\n\n    /// @notice Pending governance for 2-step transfer\n    address public pendingGovernance;\n\n    /// @notice Factory that deployed this vault\n    address public immutable factory;\n\n    /// @notice Current strategy contract (if any)\n    address public strategy;\n\n    /// @notice Total project token deposited\n    uint256 public totalProjectToken;\n\n    /// @notice Total USDC deposited\n    uint256 public totalUSDC;\n\n    /// @notice Emergency pause flag (only stops new deposits, not withdrawals)\n    bool public depositsPaused;\n\n    /// @notice Minimum deposit amount to prevent dust\n    uint256 public constant MIN_DEPOSIT = 1000; // 1000 wei minimum\n\n    /// @notice Swap fee in basis points (e.g. 30 = 0.30%)\n    uint24 public immutable swapFeeBps;\n\n    /// @notice Protocol fee recipient (0x0 disables protocol fee)\n    address public immutable protocolFeeRecipient;\n\n    /// @notice Protocol fee share of swapFee in basis points\n    uint24 public immutable protocolFeeShareBps;\n\n    /// @notice Gateway address for cross-chain liquidity aggregation\n    address public immutable gateway;\n\n    uint256 private constant BPS = 10_000;\n\n    // ============================================================================\n    // Events\n    // ============================================================================\n\n    event Deposited(\n        address indexed depositor,\n        uint256 projectTokenAmount,\n        uint256 usdcAmount,\n        uint256 sharesMinted\n    );\n\n    event Withdrawn(\n        address indexed withdrawer,\n        uint256 sharesBurned,\n        uint256 projectTokenAmount,\n        uint256 usdcAmount\n    );\n\n    event StrategyUpdated(address indexed oldStrategy, address indexed newStrategy);\n    event GovernanceTransferred(address indexed previousGovernance, address indexed newGovernance);\n    event DepositsPausedUpdated(bool paused);\n    event LiquidityRebalanced(uint256 projectTokenMoved, uint256 usdcMoved);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n\n    event LiquidityAggregated(\n        address indexed gateway,\n        uint256 projectTokenAmount,\n        uint256 usdcAmount,\n        uint32 destinationChain\n    );\n\n    event LiquidityReturned(\n        address indexed gateway,\n        uint256 projectTokenAmount,\n        uint256 usdcAmount\n    );\n\n    // ============================================================================\n    // Errors\n    // ============================================================================\n\n    error OnlyGovernance();\n    error OnlyFactory();\n    error OnlyGateway();\n    error DepositsPaused();\n    error InsufficientAmount();\n    error InvalidAddress();\n    error InvalidRatio();\n    error InsufficientShares();\n    error InsufficientLiquidity();\n    error InsufficientOutput();\n    error InvalidToken();\n\n    // ============================================================================\n    // Constructor\n    // ============================================================================\n\n    constructor(\n        address _projectToken,\n        address _usdc,\n        address _governance,\n        string memory _name,\n        string memory _symbol,\n        uint24 _swapFeeBps,\n        address _protocolFeeRecipient,\n        uint24 _protocolFeeShareBps,\n        address _gateway\n    ) ERC20(_name, _symbol) {\n        if (_projectToken == address(0) || _usdc == address(0) || _governance == address(0)) {\n            revert InvalidAddress();\n        }\n        require(_swapFeeBps < BPS, \"FEE_TOO_HIGH\");\n        require(_protocolFeeShareBps <= BPS, \"PROTOCOL_SHARE_TOO_HIGH\");\n\n        projectToken = _projectToken;\n        usdc = _usdc;\n        governance = _governance;\n        factory = msg.sender;\n        swapFeeBps = _swapFeeBps;\n        protocolFeeRecipient = _protocolFeeRecipient;\n        protocolFeeShareBps = _protocolFeeShareBps;\n        gateway = _gateway; // Can be address(0) and set later\n    }\n\n    // ============================================================================\n    // Modifiers\n    // ============================================================================\n\n    modifier onlyGovernance() {\n        if (msg.sender != governance) revert OnlyGovernance();\n        _;\n    }\n\n    modifier onlyFactory() {\n        if (msg.sender != factory) revert OnlyFactory();\n        _;\n    }\n\n    modifier onlyGateway() {\n        if (msg.sender != gateway) revert OnlyGateway();\n        _;\n    }\n\n    // ============================================================================\n    // User Functions - CANNOT BE BLOCKED BY GOVERNANCE\n    // ============================================================================\n\n    /**\n     * @notice Deposit liquidity and receive vault shares\n     * @param projectTokenAmount Amount of project token to deposit\n     * @param usdcAmount Amount of USDC to deposit\n     * @param minShares Minimum shares to mint (slippage protection)\n     * @return shares Amount of shares minted\n     */\n    function deposit(\n        uint256 projectTokenAmount,\n        uint256 usdcAmount,\n        uint256 minShares\n    ) external nonReentrant returns (uint256 shares) {\n        if (depositsPaused) revert DepositsPaused();\n        if (projectTokenAmount < MIN_DEPOSIT || usdcAmount < MIN_DEPOSIT) {\n            revert InsufficientAmount();\n        }\n\n        // Calculate shares to mint\n        uint256 _totalSupply = totalSupply();\n        \n        if (_totalSupply == 0) {\n            // First deposit: shares = sqrt(projectToken * usdc)\n            shares = _sqrt(projectTokenAmount * usdcAmount);\n            if (shares == 0) revert InsufficientAmount();\n        } else {\n            // Subsequent deposits: maintain proportional ratio\n            // shares = min(amount0 * supply / reserve0, amount1 * supply / reserve1)\n            uint256 shares0 = (projectTokenAmount * _totalSupply) / totalProjectToken;\n            uint256 shares1 = (usdcAmount * _totalSupply) / totalUSDC;\n            shares = shares0 < shares1 ? shares0 : shares1;\n        }\n\n        if (shares < minShares) revert InsufficientShares();\n\n        // Pull tokens from depositor\n        IERC20(projectToken).safeTransferFrom(msg.sender, address(this), projectTokenAmount);\n        IERC20(usdc).safeTransferFrom(msg.sender, address(this), usdcAmount);\n\n        // Update totals\n        totalProjectToken += projectTokenAmount;\n        totalUSDC += usdcAmount;\n\n        // Mint shares to depositor\n        _mint(msg.sender, shares);\n\n        emit Deposited(msg.sender, projectTokenAmount, usdcAmount, shares);\n\n        return shares;\n    }\n\n    /**\n     * @notice Withdraw liquidity by burning vault shares\n     * @dev CANNOT BE BLOCKED BY GOVERNANCE - Users always have withdrawal rights\n     * @param shares Amount of shares to burn\n     * @param minProjectToken Minimum project token to receive (slippage protection)\n     * @param minUsdc Minimum USDC to receive (slippage protection)\n     * @return projectTokenAmount Amount of project token withdrawn\n     * @return usdcAmount Amount of USDC withdrawn\n     */\n    function withdraw(\n        uint256 shares,\n        uint256 minProjectToken,\n        uint256 minUsdc\n    ) external nonReentrant returns (uint256 projectTokenAmount, uint256 usdcAmount) {\n        if (shares == 0) revert InsufficientAmount();\n        if (balanceOf(msg.sender) < shares) revert InsufficientShares();\n\n        uint256 _totalSupply = totalSupply();\n\n        // Calculate proportional amounts\n        projectTokenAmount = (shares * totalProjectToken) / _totalSupply;\n        usdcAmount = (shares * totalUSDC) / _totalSupply;\n\n        if (projectTokenAmount < minProjectToken || usdcAmount < minUsdc) {\n            revert InsufficientAmount();\n        }\n\n        // Update totals BEFORE transfers (CEI pattern)\n        totalProjectToken -= projectTokenAmount;\n        totalUSDC -= usdcAmount;\n\n        // Burn shares\n        _burn(msg.sender, shares);\n\n        // Transfer tokens to withdrawer\n        IERC20(projectToken).safeTransfer(msg.sender, projectTokenAmount);\n        IERC20(usdc).safeTransfer(msg.sender, usdcAmount);\n\n        emit Withdrawn(msg.sender, shares, projectTokenAmount, usdcAmount);\n\n        return (projectTokenAmount, usdcAmount);\n    }\n\n    // ============================================================================\n    // AMM Swap Functions - Vault functions as the liquidity pool\n    // ============================================================================\n\n    /**\n     * @notice Swap tokens using constant product formula\n     * @param tokenIn Address of input token\n     * @param amountIn Amount of input token\n     * @param amountOutMin Minimum amount of output token (slippage protection)\n     * @param to Address to receive output tokens\n     * @return amountOut Amount of output tokens received\n     */\n    function swap(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address to\n    ) external nonReentrant returns (uint256 amountOut) {\n        if (tokenIn != projectToken && tokenIn != usdc) revert InvalidToken();\n        if (to == address(0)) revert InvalidAddress();\n        if (amountIn == 0) revert InsufficientAmount();\n\n        address tokenOut = tokenIn == projectToken ? usdc : projectToken;\n        \n        // Get current reserves\n        uint256 reserveIn = tokenIn == projectToken ? totalProjectToken : totalUSDC;\n        uint256 reserveOut = tokenIn == projectToken ? totalUSDC : totalProjectToken;\n\n        if (reserveIn == 0 || reserveOut == 0) revert InsufficientLiquidity();\n\n        // Apply swap fee\n        uint256 amountInAfterFee = (amountIn * (BPS - swapFeeBps)) / BPS;\n        \n        // Calculate protocol fee\n        uint256 protocolFee = 0;\n        if (protocolFeeRecipient != address(0) && protocolFeeShareBps > 0) {\n            uint256 totalFee = amountIn - amountInAfterFee;\n            protocolFee = (totalFee * protocolFeeShareBps) / BPS;\n        }\n\n        // Constant product formula: (amountIn * reserveOut) / (reserveIn + amountIn)\n        uint256 numerator = amountInAfterFee * reserveOut;\n        uint256 denominator = reserveIn + amountInAfterFee;\n        amountOut = numerator / denominator;\n\n        if (amountOut < amountOutMin) revert InsufficientOutput();\n        if (amountOut == 0) revert InsufficientOutput();\n\n        // Transfer input token from user\n        IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n\n        // Transfer protocol fee if applicable\n        if (protocolFee > 0) {\n            IERC20(tokenIn).safeTransfer(protocolFeeRecipient, protocolFee);\n        }\n\n        // Update reserves\n        if (tokenIn == projectToken) {\n            totalProjectToken += amountInAfterFee;\n            totalUSDC -= amountOut;\n            if (totalUSDC < amountOut) revert InsufficientLiquidity();\n        } else {\n            totalUSDC += amountInAfterFee;\n            totalProjectToken -= amountOut;\n            if (totalProjectToken < amountOut) revert InsufficientLiquidity();\n        }\n\n        // Transfer output token to user\n        IERC20(tokenOut).safeTransfer(to, amountOut);\n\n        // Emit swap event\n        if (tokenIn == projectToken) {\n            emit Swap(msg.sender, amountIn, 0, 0, amountOut, to);\n        } else {\n            emit Swap(msg.sender, 0, amountIn, amountOut, 0, to);\n        }\n\n        return amountOut;\n    }\n\n    /**\n     * @notice Get token addresses (for compatibility with pool interface)\n     * @return token0 First token (projectToken)\n     * @return token1 Second token (usdc)\n     */\n    function getTokens() external view returns (address token0, address token1) {\n        return (projectToken, usdc);\n    }\n\n    // ============================================================================\n    // Gateway Functions - CROSS-CHAIN LIQUIDITY AGGREGATION\n    // ============================================================================\n\n    /**\n     * @notice Withdraw liquidity for cross-chain aggregation (Gateway only)\n     * @dev Gateway can drain vault liquidity for cross-chain swaps\n     * @param destinationChain Chain ID where liquidity is being aggregated\n     * @return projectTokenAmount Amount of project token withdrawn\n     * @return usdcAmount Amount of USDC withdrawn\n     */\n    function withdrawForAggregation(uint32 destinationChain) \n        external \n        onlyGateway \n        nonReentrant \n        returns (uint256 projectTokenAmount, uint256 usdcAmount) \n    {\n        projectTokenAmount = totalProjectToken;\n        usdcAmount = totalUSDC;\n\n        // Transfer all liquidity to gateway\n        if (projectTokenAmount > 0) {\n            IERC20(projectToken).safeTransfer(gateway, projectTokenAmount);\n        }\n        if (usdcAmount > 0) {\n            IERC20(usdc).safeTransfer(gateway, usdcAmount);\n        }\n\n        // Reset totals (will be repopulated when liquidity returns)\n        totalProjectToken = 0;\n        totalUSDC = 0;\n\n        emit LiquidityAggregated(gateway, projectTokenAmount, usdcAmount, destinationChain);\n\n        return (projectTokenAmount, usdcAmount);\n    }\n\n    /**\n     * @notice Return liquidity after cross-chain aggregation (Gateway only)\n     * @dev Gateway returns liquidity with potentially different proportions after rebalancing\n     * @param projectTokenAmount Amount of project token to return\n     * @param usdcAmount Amount of USDC to return\n     */\n    function returnLiquidity(uint256 projectTokenAmount, uint256 usdcAmount) \n        external \n        onlyGateway \n        nonReentrant \n    {\n        if (projectTokenAmount == 0 && usdcAmount == 0) revert InsufficientAmount();\n\n        // Transfer liquidity from gateway back to vault\n        if (projectTokenAmount > 0) {\n            IERC20(projectToken).safeTransferFrom(gateway, address(this), projectTokenAmount);\n            totalProjectToken += projectTokenAmount;\n        }\n        if (usdcAmount > 0) {\n            IERC20(usdc).safeTransferFrom(gateway, address(this), usdcAmount);\n            totalUSDC += usdcAmount;\n        }\n\n        emit LiquidityReturned(gateway, projectTokenAmount, usdcAmount);\n    }\n\n    // ============================================================================\n    // Governance Functions - STRATEGY CONTROL ONLY\n    // ============================================================================\n\n    /**\n     * @notice Set strategy contract that can manage liquidity\n     * @dev Governance can update strategy but cannot prevent user withdrawals\n     * @param newStrategy Address of new strategy contract\n     */\n    function setStrategy(address newStrategy) external onlyGovernance {\n        address oldStrategy = strategy;\n        strategy = newStrategy;\n        emit StrategyUpdated(oldStrategy, newStrategy);\n    }\n\n    /**\n     * @notice Approve tokens to strategy for liquidity management\n     * @dev Only governance can call, but this doesn't affect user withdrawal rights\n     * @param token Token to approve\n     * @param amount Amount to approve\n     */\n    function approveStrategy(address token, uint256 amount) external onlyGovernance {\n        if (strategy == address(0)) revert InvalidAddress();\n        if (token != projectToken && token != usdc) revert InvalidAddress();\n        \n        // Use forceApprove for OpenZeppelin 5.x\n        IERC20(token).safeIncreaseAllowance(strategy, amount);\n    }\n\n    /**\n     * @notice Rebalance liquidity across chains or DEXes via strategy\n     * @dev Governance manages allocation but cannot take user funds\n     * @param data Encoded strategy call data\n     */\n    function rebalance(bytes calldata data) external onlyGovernance returns (bytes memory) {\n        if (strategy == address(0)) revert InvalidAddress();\n        \n        // Record balances before\n        uint256 projectTokenBefore = IERC20(projectToken).balanceOf(address(this));\n        uint256 usdcBefore = IERC20(usdc).balanceOf(address(this));\n\n        // Execute strategy\n        (bool success, bytes memory returnData) = strategy.call(data);\n        require(success, \"Strategy call failed\");\n\n        // Record balances after\n        uint256 projectTokenAfter = IERC20(projectToken).balanceOf(address(this));\n        uint256 usdcAfter = IERC20(usdc).balanceOf(address(this));\n\n        // Update totals if rebalancing changed amounts\n        // (This can happen if strategy earned fees or moved liquidity)\n        totalProjectToken = projectTokenAfter;\n        totalUSDC = usdcAfter;\n\n        emit LiquidityRebalanced(\n            projectTokenAfter > projectTokenBefore ? projectTokenAfter - projectTokenBefore : 0,\n            usdcAfter > usdcBefore ? usdcAfter - usdcBefore : 0\n        );\n\n        return returnData;\n    }\n\n    /**\n     * @notice Pause new deposits (emergency only)\n     * @dev Does NOT affect withdrawals - users can always withdraw\n     * @param paused True to pause deposits, false to unpause\n     */\n    function setDepositsPaused(bool paused) external onlyGovernance {\n        depositsPaused = paused;\n        emit DepositsPausedUpdated(paused);\n    }\n\n    /**\n     * @notice Transfer governance to new address (2-step process)\n     * @param newGovernance Address of new governance\n     */\n    function transferGovernance(address newGovernance) external onlyGovernance {\n        if (newGovernance == address(0)) revert InvalidAddress();\n        pendingGovernance = newGovernance;\n    }\n\n    /**\n     * @notice Accept governance transfer\n     */\n    function acceptGovernance() external {\n        if (msg.sender != pendingGovernance) revert OnlyGovernance();\n        address oldGovernance = governance;\n        governance = pendingGovernance;\n        pendingGovernance = address(0);\n        emit GovernanceTransferred(oldGovernance, governance);\n    }\n\n    // ============================================================================\n    // View Functions\n    // ============================================================================\n\n    /**\n     * @notice Get the amount of tokens a user would receive for burning shares\n     * @param shares Amount of shares\n     * @return projectTokenAmount Amount of project token\n     * @return usdcAmount Amount of USDC\n     */\n    function previewWithdraw(uint256 shares) \n        external \n        view \n        returns (uint256 projectTokenAmount, uint256 usdcAmount) \n    {\n        if (shares == 0 || totalSupply() == 0) return (0, 0);\n        \n        uint256 _totalSupply = totalSupply();\n        projectTokenAmount = (shares * totalProjectToken) / _totalSupply;\n        usdcAmount = (shares * totalUSDC) / _totalSupply;\n    }\n\n    /**\n     * @notice Get current reserves\n     * @return projectTokenReserve Amount of project token in vault\n     * @return usdcReserve Amount of USDC in vault\n     */\n    function getReserves() external view returns (uint256 projectTokenReserve, uint256 usdcReserve) {\n        return (totalProjectToken, totalUSDC);\n    }\n\n    /**\n     * @notice Calculate value of shares in terms of reserves\n     * @param shares Amount of shares\n     * @return value0 Value in terms of project token\n     * @return value1 Value in terms of USDC\n     */\n    function shareValue(uint256 shares) external view returns (uint256 value0, uint256 value1) {\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply == 0) return (0, 0);\n        \n        value0 = (shares * totalProjectToken) / _totalSupply;\n        value1 = (shares * totalUSDC) / _totalSupply;\n    }\n\n    // ============================================================================\n    // Internal Functions\n    // ============================================================================\n\n    /**\n     * @notice Square root function for initial share calculation\n     * @param y Input value\n     * @return z Square root of y\n     */\n    function _sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n\n"
      },
      "project/core/MockERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    uint8 private immutable _decimals;\n\n    constructor(string memory name_, string memory symbol_, uint8 decimals_)\n        ERC20(name_, symbol_)\n    {\n        _decimals = decimals_;\n        _mint(msg.sender, 1_000_000_000 * (10 ** decimals_)); // 1B tokens\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n}"
      },
      "project/core/TokenRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title TokenRegistry\n * @notice Source of truth for cross-chain token mappings and vault addresses\n * @dev Only registered tokens can be moved via Gateway or swapped via Router\n */\ncontract TokenRegistry {\n    // ============================================================================\n    // Structures\n    // ============================================================================\n\n    struct TokenInfo {\n        bool registered;\n        string symbol;\n        string name;\n        uint8 decimals;\n        address vaultAddress; // LiquidityVault for this token on this chain\n    }\n\n    struct ChainInfo {\n        uint32 chainId;\n        bool active;\n        address gatewayWallet; // Circle Gateway wallet on this chain\n        string rpcUrl; // For off-chain indexing\n    }\n\n    // ============================================================================\n    // State Variables\n    // ============================================================================\n\n    /// @notice Governance address with registry management rights\n    address public governance;\n\n    /// @notice Pending governance for 2-step transfer\n    address public pendingGovernance;\n\n    /// @notice Mapping: tokenId => chainId => TokenInfo\n    /// @dev tokenId is a unique identifier (e.g., keccak256(\"FLX\"))\n    mapping(bytes32 => mapping(uint32 => TokenInfo)) public tokens;\n\n    /// @notice Mapping: chainId => ChainInfo\n    mapping(uint32 => ChainInfo) public chains;\n\n    /// @notice List of all registered token IDs\n    bytes32[] public tokenIds;\n\n    /// @notice List of all registered chain IDs\n    uint32[] public chainIds;\n\n    /// @notice Mapping to track if tokenId is in array\n    mapping(bytes32 => bool) private _tokenIdExists;\n\n    /// @notice Mapping to track if chainId is in array\n    mapping(uint32 => bool) private _chainIdExists;\n\n    // ============================================================================\n    // Events\n    // ============================================================================\n\n    event TokenRegistered(\n        bytes32 indexed tokenId,\n        uint32 indexed chainId,\n        address tokenAddress,\n        address vaultAddress,\n        string symbol\n    );\n\n    event TokenUnregistered(\n        bytes32 indexed tokenId,\n        uint32 indexed chainId\n    );\n\n    event VaultUpdated(\n        bytes32 indexed tokenId,\n        uint32 indexed chainId,\n        address oldVault,\n        address newVault\n    );\n\n    event ChainRegistered(\n        uint32 indexed chainId,\n        address gatewayWallet\n    );\n\n    event ChainUpdated(\n        uint32 indexed chainId,\n        bool active,\n        address gatewayWallet\n    );\n\n    event GovernanceTransferred(\n        address indexed previousGovernance,\n        address indexed newGovernance\n    );\n\n    // ============================================================================\n    // Errors\n    // ============================================================================\n\n    error OnlyGovernance();\n    error TokenNotRegistered();\n    error TokenAlreadyRegistered();\n    error ChainNotActive();\n    error InvalidAddress();\n    error InvalidChainId();\n\n    // ============================================================================\n    // Constructor\n    // ============================================================================\n\n    constructor() {\n        governance = msg.sender;\n    }\n\n    // ============================================================================\n    // Modifiers\n    // ============================================================================\n\n    modifier onlyGovernance() {\n        if (msg.sender != governance) revert OnlyGovernance();\n        _;\n    }\n\n    // ============================================================================\n    // Governance Functions\n    // ============================================================================\n\n    /**\n     * @notice Register a new chain\n     * @param chainId Chain ID (e.g., 97 for BSC Testnet)\n     * @param gatewayWallet Circle Gateway wallet address on this chain\n     * @param rpcUrl RPC URL for off-chain services\n     */\n    function registerChain(\n        uint32 chainId,\n        address gatewayWallet,\n        string calldata rpcUrl\n    ) external onlyGovernance {\n        if (chainId == 0) revert InvalidChainId();\n\n        chains[chainId] = ChainInfo({\n            chainId: chainId,\n            active: true,\n            gatewayWallet: gatewayWallet,\n            rpcUrl: rpcUrl\n        });\n\n        if (!_chainIdExists[chainId]) {\n            chainIds.push(chainId);\n            _chainIdExists[chainId] = true;\n        }\n\n        emit ChainRegistered(chainId, gatewayWallet);\n    }\n\n    /**\n     * @notice Update chain configuration\n     * @param chainId Chain ID to update\n     * @param active Whether chain is active\n     * @param gatewayWallet New gateway wallet address\n     */\n    function updateChain(\n        uint32 chainId,\n        bool active,\n        address gatewayWallet\n    ) external onlyGovernance {\n        if (chains[chainId].chainId == 0) revert InvalidChainId();\n        \n        chains[chainId].active = active;\n        if (gatewayWallet != address(0)) {\n            chains[chainId].gatewayWallet = gatewayWallet;\n        }\n\n        emit ChainUpdated(chainId, active, gatewayWallet);\n    }\n\n    /**\n     * @notice Register a token on a specific chain\n     * @param tokenId Unique identifier (e.g., keccak256(\"FLX\"))\n     * @param chainId Chain ID where token exists\n     * @param tokenAddress ERC20 contract address on this chain\n     * @param vaultAddress LiquidityVault address for this token on this chain\n     * @param symbol Token symbol\n     * @param name Token name\n     * @param decimals Token decimals\n     */\n    function registerToken(\n        bytes32 tokenId,\n        uint32 chainId,\n        address tokenAddress,\n        address vaultAddress,\n        string calldata symbol,\n        string calldata name,\n        uint8 decimals\n    ) external onlyGovernance {\n        if (tokenAddress == address(0)) revert InvalidAddress();\n        if (!chains[chainId].active) revert ChainNotActive();\n        if (tokens[tokenId][chainId].registered) revert TokenAlreadyRegistered();\n\n        tokens[tokenId][chainId] = TokenInfo({\n            registered: true,\n            symbol: symbol,\n            name: name,\n            decimals: decimals,\n            vaultAddress: vaultAddress\n        });\n\n        // Add to tokenIds array if new\n        if (!_tokenIdExists[tokenId]) {\n            tokenIds.push(tokenId);\n            _tokenIdExists[tokenId] = true;\n        }\n\n        emit TokenRegistered(tokenId, chainId, tokenAddress, vaultAddress, symbol);\n    }\n\n    /**\n     * @notice Update vault address for a registered token\n     * @param tokenId Token identifier\n     * @param chainId Chain ID\n     * @param newVaultAddress New vault address\n     */\n    function updateVault(\n        bytes32 tokenId,\n        uint32 chainId,\n        address newVaultAddress\n    ) external onlyGovernance {\n        if (!tokens[tokenId][chainId].registered) revert TokenNotRegistered();\n\n        address oldVault = tokens[tokenId][chainId].vaultAddress;\n        tokens[tokenId][chainId].vaultAddress = newVaultAddress;\n\n        emit VaultUpdated(tokenId, chainId, oldVault, newVaultAddress);\n    }\n\n    /**\n     * @notice Unregister a token on a specific chain\n     * @param tokenId Token identifier\n     * @param chainId Chain ID\n     */\n    function unregisterToken(\n        bytes32 tokenId,\n        uint32 chainId\n    ) external onlyGovernance {\n        if (!tokens[tokenId][chainId].registered) revert TokenNotRegistered();\n\n        delete tokens[tokenId][chainId];\n        emit TokenUnregistered(tokenId, chainId);\n    }\n\n    /**\n     * @notice Transfer governance (2-step)\n     * @param newGovernance New governance address\n     */\n    function transferGovernance(address newGovernance) external onlyGovernance {\n        if (newGovernance == address(0)) revert InvalidAddress();\n        pendingGovernance = newGovernance;\n    }\n\n    /**\n     * @notice Accept governance transfer\n     */\n    function acceptGovernance() external {\n        if (msg.sender != pendingGovernance) revert OnlyGovernance();\n        address oldGovernance = governance;\n        governance = pendingGovernance;\n        pendingGovernance = address(0);\n        emit GovernanceTransferred(oldGovernance, governance);\n    }\n\n    // ============================================================================\n    // View Functions\n    // ============================================================================\n\n    /**\n     * @notice Check if a token is registered on a chain\n     * @param tokenId Token identifier\n     * @param chainId Chain ID\n     * @return bool True if registered\n     */\n    function isTokenRegistered(bytes32 tokenId, uint32 chainId) external view returns (bool) {\n        return tokens[tokenId][chainId].registered;\n    }\n\n    /**\n     * @notice Get token info on a specific chain\n     * @param tokenId Token identifier\n     * @param chainId Chain ID\n     * @return info TokenInfo struct\n     */\n    function getTokenInfo(bytes32 tokenId, uint32 chainId) \n        external \n        view \n        returns (TokenInfo memory info) \n    {\n        if (!tokens[tokenId][chainId].registered) revert TokenNotRegistered();\n        return tokens[tokenId][chainId];\n    }\n\n    /**\n     * @notice Get vault address for a token on a chain\n     * @param tokenId Token identifier\n     * @param chainId Chain ID\n     * @return vaultAddress Vault address\n     */\n    function getVault(bytes32 tokenId, uint32 chainId) \n        external \n        view \n        returns (address vaultAddress) \n    {\n        if (!tokens[tokenId][chainId].registered) revert TokenNotRegistered();\n        return tokens[tokenId][chainId].vaultAddress;\n    }\n\n    /**\n     * @notice Get Gateway wallet for a chain\n     * @param chainId Chain ID\n     * @return gatewayWallet Gateway wallet address\n     */\n    function getGatewayWallet(uint32 chainId) \n        external \n        view \n        returns (address gatewayWallet) \n    {\n        if (!chains[chainId].active) revert ChainNotActive();\n        return chains[chainId].gatewayWallet;\n    }\n\n    /**\n     * @notice Get all chains where a token is registered\n     * @param tokenId Token identifier\n     * @return registeredChainIds Array of chain IDs\n     */\n    function getTokenChains(bytes32 tokenId) \n        external \n        view \n        returns (uint32[] memory registeredChainIds) \n    {\n        uint256 count = 0;\n        \n        // First pass: count registered chains\n        for (uint256 i = 0; i < chainIds.length; i++) {\n            if (tokens[tokenId][chainIds[i]].registered) {\n                count++;\n            }\n        }\n\n        // Second pass: populate array\n        registeredChainIds = new uint32[](count);\n        uint256 index = 0;\n        for (uint256 i = 0; i < chainIds.length; i++) {\n            if (tokens[tokenId][chainIds[i]].registered) {\n                registeredChainIds[index] = chainIds[i];\n                index++;\n            }\n        }\n\n        return registeredChainIds;\n    }\n\n    /**\n     * @notice Get all registered tokens\n     * @return Array of token IDs\n     */\n    function getAllTokens() external view returns (bytes32[] memory) {\n        return tokenIds;\n    }\n\n    /**\n     * @notice Get all registered chains\n     * @return Array of chain IDs\n     */\n    function getAllChains() external view returns (uint32[] memory) {\n        return chainIds;\n    }\n\n    /**\n     * @notice Helper to create token ID from symbol\n     * @param symbol Token symbol (e.g., \"FLX\")\n     * @return tokenId bytes32 identifier\n     */\n    function getTokenId(string calldata symbol) external pure returns (bytes32) {\n        return keccak256(abi.encodePacked(symbol));\n    }\n}\n\n"
      },
      "project/core/VaultFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {LiquidityVault} from \"./LiquidityVault.sol\";\n\n/**\n * @title VaultFactory\n * @notice Factory for deploying LiquidityVault contracts across multiple chains\n * @dev Maintains registry of all vaults and provides deterministic addressing\n */\ncontract VaultFactory {\n    // ============================================================================\n    // State Variables\n    // ============================================================================\n\n    /// @notice Governance address with deployment rights\n    address public governance;\n\n    /// @notice Pending governance for 2-step transfer\n    address public pendingGovernance;\n\n    /// @notice USDC token address on this chain\n    address public immutable usdc;\n\n    /// @notice Gateway address for cross-chain liquidity aggregation\n    address public gateway;\n\n    /// @notice Mapping of projectToken => vault address\n    mapping(address => address) public getVault;\n\n    /// @notice Array of all vaults\n    address[] public allVaults;\n\n    /// @notice Fee recipient for protocol fees\n    address public feeRecipient;\n\n    /// @notice Protocol fee in basis points (e.g., 10 = 0.1%)\n    uint256 public protocolFeeBps;\n\n    /// @notice Swap fee in basis points for vaults (e.g., 30 = 0.30%)\n    uint24 public swapFeeBps;\n\n    // ============================================================================\n    // Events\n    // ============================================================================\n\n    event VaultCreated(\n        address indexed projectToken,\n        address indexed vault,\n        uint256 index\n    );\n\n    event GovernanceTransferred(\n        address indexed previousGovernance,\n        address indexed newGovernance\n    );\n\n    event FeeRecipientUpdated(address indexed newFeeRecipient);\n    event ProtocolFeeUpdated(uint256 newFeeBps);\n    event GatewayUpdated(address indexed oldGateway, address indexed newGateway);\n\n    // ============================================================================\n    // Errors\n    // ============================================================================\n\n    error OnlyGovernance();\n    error VaultExists();\n    error InvalidAddress();\n    error FeeTooHigh();\n\n    // ============================================================================\n    // Constructor\n    // ============================================================================\n\n    constructor(address _usdc, address _feeRecipient, uint24 _swapFeeBps, address _gateway) {\n        if (_usdc == address(0) || _feeRecipient == address(0)) {\n            revert InvalidAddress();\n        }\n\n        governance = msg.sender;\n        usdc = _usdc;\n        feeRecipient = _feeRecipient;\n        protocolFeeBps = 10; // 0.1% default\n        swapFeeBps = _swapFeeBps; // Default 30 (0.30%)\n        gateway = _gateway; // Can be address(0) initially and set later\n    }\n\n    // ============================================================================\n    // Modifiers\n    // ============================================================================\n\n    modifier onlyGovernance() {\n        if (msg.sender != governance) revert OnlyGovernance();\n        _;\n    }\n\n    // ============================================================================\n    // Core Functions\n    // ============================================================================\n\n    /**\n     * @notice Create a new liquidity vault for a project token\n     * @param projectToken Address of the project token\n     * @param name Name for the vault shares token\n     * @param symbol Symbol for the vault shares token\n     * @return vault Address of the newly created vault\n     */\n    function createVault(\n        address projectToken,\n        string memory name,\n        string memory symbol\n    ) external returns (address vault) {\n        if (projectToken == address(0) || projectToken == usdc) {\n            revert InvalidAddress();\n        }\n\n        if (getVault[projectToken] != address(0)) {\n            revert VaultExists();\n        }\n\n        // Deploy new vault (vault functions as both vault and AMM pool)\n        vault = address(new LiquidityVault(\n            projectToken,\n            usdc,\n            governance,\n            name,\n            symbol,\n            swapFeeBps,\n            feeRecipient,\n            uint24(protocolFeeBps),\n            gateway  // Pass gateway address to vault\n        ));\n\n        // Register vault\n        getVault[projectToken] = vault;\n        allVaults.push(vault);\n\n        emit VaultCreated(projectToken, vault, allVaults.length - 1);\n\n        return vault;\n    }\n\n    /**\n     * @notice Get total number of vaults\n     * @return count Number of vaults created\n     */\n    function allVaultsLength() external view returns (uint256) {\n        return allVaults.length;\n    }\n\n    /**\n     * @notice Get vault info by index\n     * @param index Index in allVaults array\n     * @return vault Address of vault\n     * @return projectToken Address of project token\n     */\n    function getVaultByIndex(uint256 index) external view returns (address vault, address projectToken) {\n        vault = allVaults[index];\n        projectToken = LiquidityVault(vault).projectToken();\n    }\n\n    // ============================================================================\n    // Governance Functions\n    // ============================================================================\n\n    /**\n     * @notice Set fee recipient address\n     * @param newFeeRecipient New fee recipient\n     */\n    function setFeeRecipient(address newFeeRecipient) external onlyGovernance {\n        if (newFeeRecipient == address(0)) revert InvalidAddress();\n        feeRecipient = newFeeRecipient;\n        emit FeeRecipientUpdated(newFeeRecipient);\n    }\n\n    /**\n     * @notice Set protocol fee\n     * @param newFeeBps New fee in basis points\n     */\n    function setProtocolFee(uint256 newFeeBps) external onlyGovernance {\n        if (newFeeBps > 1000) revert FeeTooHigh(); // Max 10%\n        protocolFeeBps = newFeeBps;\n        emit ProtocolFeeUpdated(newFeeBps);\n    }\n\n    /**\n     * @notice Set gateway address for cross-chain aggregation\n     * @param newGateway New gateway address\n     */\n    function setGateway(address newGateway) external onlyGovernance {\n        address oldGateway = gateway;\n        gateway = newGateway;\n        emit GatewayUpdated(oldGateway, newGateway);\n    }\n\n    /**\n     * @notice Transfer governance to new address (2-step process)\n     * @param newGovernance Address of new governance\n     */\n    function transferGovernance(address newGovernance) external onlyGovernance {\n        if (newGovernance == address(0)) revert InvalidAddress();\n        pendingGovernance = newGovernance;\n    }\n\n    /**\n     * @notice Accept governance transfer\n     */\n    function acceptGovernance() external {\n        if (msg.sender != pendingGovernance) revert OnlyGovernance();\n        address oldGovernance = governance;\n        governance = pendingGovernance;\n        pendingGovernance = address(0);\n        emit GovernanceTransferred(oldGovernance, governance);\n    }\n}\n\n"
      },
      "project/core/WrappedToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title WrappedToken\n * @notice ERC20 token representing wrapped version of a token from another chain\n * @dev Only the Gateway contract can mint/burn these tokens\n */\ncontract WrappedToken is ERC20, Ownable {\n    /// @notice Gateway contract that can mint/burn tokens\n    address public gateway;\n\n    /// @notice Original chain ID where real tokens are locked\n    uint32 public immutable originChainId;\n\n    /// @notice Original token address on origin chain\n    address public immutable originToken;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint32 _originChainId,\n        address _originToken\n    ) ERC20(name, symbol) Ownable(msg.sender) {\n        originChainId = _originChainId;\n        originToken = _originToken;\n    }\n\n    function setGateway(address _gateway) external onlyOwner {\n        require(_gateway != address(0), \"ZERO_ADDRESS\");\n        gateway = _gateway;\n    }\n\n    function mint(address to, uint256 amount) external {\n        require(msg.sender == gateway, \"ONLY_GATEWAY\");\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) external {\n        require(msg.sender == gateway, \"ONLY_GATEWAY\");\n        _burn(from, amount);\n    }\n}\n\n"
      }
    }
  }
}